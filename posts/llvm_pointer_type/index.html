<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title></title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://bemg.github.io/blog/posts/llvm_pointer_type/">
	<meta name="og:site_name" content="">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="https://bemg.github.io/blog/css/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>

<body>

<header>
	
	<a href="https://bemg.github.io/blog/" style="float: left;color:#777;"><strong>BeMg</strong></a>
	
	&nbsp;&nbsp;&nbsp;&nbsp;
	
	
	
	<a href="https://bemg.github.io/blog/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1> <aside></aside></h1>
  

<h1 id="llvm-pointer-type-解析">LLVM pointer type 解析</h1>

<p>寫個作業發現居然沒有對於 LLVM pointer type 的詳細說明，難怪沒有人要做 compiler，文件都那麼不友善。明明 pointer 是這麼常用的到東西。一堆 dereference 的星星。</p>

<p>本文基於C language 對於 llvm IR 的轉換進行介紹。</p>

<h2 id="目錄">目錄</h2>

<ul>
<li><p>名詞定義</p>

<ul>
<li>pointer type</li>
<li>reference</li>
<li>dereference</li>
</ul></li>

<li><p>LLVM IR</p></li>
</ul>

<h2 id="名詞定義">名詞定義</h2>

<h3 id="pointer-type">Pointer type</h3>

<p>在C語言中，我們使用 pointer 會是一個指向某一個 address 的 variable。</p>

<pre><code class="language-c">int *p;
int x;
p = &amp;x;
</code></pre>

<h3 id="reference">Reference</h3>

<p>每個變數都有值(value)跟位址(address)，pointer type 只是剛好 value 是某一個 address。所謂的 Reference 就是指用一個關鍵字去取得一個特定變數的address。</p>

<pre><code class="language-c">int *p;
printf(&quot;%p\n&quot;, &amp;p);
</code></pre>

<h3 id="dereference">dereference</h3>

<p>這個操作是指 reference 的反向，如果可以從一個變數取得它的位址，那麼也可以從一個位址取得它的值。</p>

<pre><code class="language-c">int *p;
int x = 10;
p = &amp;x;
printf(&quot;%d\n&quot;, *p);
</code></pre>

<h2 id="llvm-ir">LLVM IR</h2>

<p>但是以上的各種名詞定義都僅僅應用在C語言層級。LLVM IR 更像是一種組合語言，對於組合語言來說，就沒有什麼 Reference、dereference。需要關注的，只有三種指令。</p>

<ul>
<li>alloca

<ul>
<li>宣告一段空間給變數</li>
</ul></li>
<li>load

<ul>
<li>從某個address取得其值</li>
</ul></li>
<li>store

<ul>
<li>將某個值放入某個address</li>
</ul></li>
</ul>

<p>當然實際上還要再更複雜一點。接下來我們來看一下這個LLVM IR範例。</p>

<pre><code class="language-c">  // This is C source code
  int x, y, *p, **pp;
  p = &amp;x;
  pp = &amp;p;
  *pp = &amp;y;
  *p = 3;
  **pp = *p;

  // This is LLVM IR transform by clang
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32*, align 8
  %4 = alloca i32**, align 8
  
  store i32* %1, i32** %3, align 8
  
  store i32** %3, i32*** %4, align 8
  
  %5 = load i32**, i32*** %4, align 8
  store i32* %2, i32** %5, align 8
  
  %6 = load i32*, i32** %3, align 8
  store i32 3, i32* %6, align 4
  
  %7 = load i32*, i32** %3, align 8   
  %8 = load i32, i32* %7, align 4     
  %9 = load i32**, i32*** %4, align 8 
  %10 = load i32*, i32** %9, align 8  
  store i32 %8, i32* %10, align 4
</code></pre>

<p>我們可以在C語言層級重新看待這段程式碼。</p>

<pre><code>**pp - *pp - pp - &amp;pp
</code></pre>

<ul>
<li>當star數與實際宣告型態相同時，變數是原始型態</li>
</ul>

<pre><code>i32 %1    -&gt; x
i32 %2    -&gt; y
i32 * %3  -&gt; p
i32 ** %4 -&gt; pp
</code></pre>

<ul>
<li>當多一個star的時候為reference，當少一個星時候為dereference，但是實務上只會有多一個星的狀況發生。

<ul>
<li>因為 reference 是去取得一個constant的位址，dereference 是去取得一個動態的值。</li>
<li>前者可以亂來，後者要靠指令。</li>
</ul></li>
</ul>

<pre><code class="language-c">store i32* %1, i32** %3, align 8
// %1 -&gt; int x
// %3 -&gt; int *p
</code></pre>

<p>我們先回歸所謂 store 指令的定義，store 的本質為，<strong>將一個 value ，存入一個 address 中</strong>。剛好，pointer type 其中的 value 就是 address。所以很容易造成混淆。</p>

<p>我們來逐個 operand 進行分析。</p>

<pre><code class="language-c">// %1 -&gt; x
// x - &amp;x
// 多一個star，向右一格
i32* %1 -&gt; &amp;x
</code></pre>

<pre><code class="language-c">// %3 -&gt; *p
// *p - p - &amp;p
// 多一個star，向右一格
i32** %3 -&gt; &amp;p
</code></pre>

<p>但是我們還要考慮store的本質，所以我們是存值回 address of p。</p>

<pre><code class="language-c">p = &amp;x;
</code></pre>

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
