<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Introduction to Spike</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Introduction to Spike">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="Introduction to Spike">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://bemg.github.io/blog/posts/introduction-to-spike/">
	<meta name="og:site_name" content="Introduction to Spike">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="https://bemg.github.io/blog/css/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>

<body>

<header>
	
	<a href="https://bemg.github.io/blog/" style="float: left;color:#777;"><strong>BeMg</strong></a>
	
	&nbsp;&nbsp;&nbsp;&nbsp;
	
	
	
	<a href="https://bemg.github.io/blog/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>Introduction to Spike <aside></aside></h1>
  

<h2 id="前言">前言</h2>

<p>最近花了大概兩個禮拜研究了 RISCV 的官方模擬器 (riscv-isa-sim) Spike。</p>

<p>內容包含</p>

<ul>
<li>安裝</li>
<li>基本使用</li>
<li>如何加入新的指令</li>
</ul>

<h2 id="安裝">安裝</h2>

<p>在使用 spike 之前，需要安裝 riscv-tools，所需要的工具大致如下</p>

<ul>
<li><strong>riscv-gnu-toolchain: RISC-V cross-compiler</strong></li>
<li>riscv-fesvr: a &ldquo;front-end&rdquo; server that services calls between the host and target processors on the Host-Target InterFace</li>
<li><strong>riscv-isa-sim: ISA simulator, as kown as spike</strong></li>
<li><strong>riscv-opcodes: the enumeration of all RISC-V opcodes executable by the simulator</strong></li>
<li>riscv-pk: a proxy kernel that services system calls generated by code built and linked with the RISC-V Newlib port</li>
<li>riscv-tests: a set of assembly tests and benchmarks</li>
</ul>

<p>粗體的部份是使用 spike 會需要理解的部份。</p>

<pre><code class="language-shell">git clone https://github.com/riscv/riscv-tools.git
cd riscv-tools
git submodule update --init --recursive
export RISCV=/path/to/install/riscv/toolchain
./build.sh
export $RISCV/bin to $PATH
</code></pre>

<blockquote>
<p>覺得編譯速度不夠快可以去修改 build.sh 使用多核心</p>
</blockquote>

<h2 id="如何使用-spike">如何使用 spike</h2>

<p>寫程式 -&gt; 用 cross-over compiler 編譯出 riscv machine code -&gt; 使用 spike 運行此執行檔</p>

<ul>
<li>寫程式</li>
</ul>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    int a = 1*2*3*4;
    printf(&quot;%d\n&quot;, a);
    return 0;
}
</code></pre>

<ul>
<li>使用cross-over compiler 編譯</li>
</ul>

<pre><code class="language-shell">riscv64-unknown-elf-gcc main.c -o main
</code></pre>

<ul>
<li>使用 spike 運行此程式</li>
</ul>

<pre><code>spike pk main
</code></pre>

<h2 id="如何加入新的指令">如何加入新的指令</h2>

<p>spike 是一個 riscv 的模擬器，最主要的目標就是在沒有支援 riscv ISA 的處理器上，也可以執行以 riscv machine code 為主的程式。方便程式開發與測試。其本身就是在定義一個符合 riscv 規格的處理器。有 register 有 memory 最大程度的重現真實CPU的行為。</p>

<blockquote>
<p>當然，結果正確無誤比起流程正確無誤重要。</p>
</blockquote>

<ul>
<li>定義指令編碼與生成mask</li>
<li>描述指令行為</li>
<li>註冊進spike</li>
<li>測試新的指令</li>
</ul>

<p>這一個章節會以 <code>vfadd.s</code> 作為範例</p>

<ul>
<li>格式

<ul>
<li><code>vfadd.s rd rs1 rs2</code></li>
</ul></li>
<li>讀取 rs1 與 rs2 的值，並且將加在一起的結果存在 rd。</li>
<li>操作皆為浮點數</li>
</ul>

<h3 id="定義指令編碼與生成mask">定義指令編碼與生成mask</h3>

<p>首先必須定義好專屬於這個指令的編碼，這樣才可以在 spike 辨識出這個指令並且執行特定的行為。</p>

<pre><code class="language-c">vfadd.s rd rs1 rs2 31..25=0 14..12=6 6..2=0x02 1..0=3
</code></pre>

<p>上述編碼會將其定義在 <code>riscv-tools/riscv-opcodes/opcodes</code>，這個檔案中存放有所有 spike 可以識別指令的編碼。理論上是不能有重覆的。</p>

<blockquote>
<p>實際上有可能會出現某些指令寄生在其他指令身上的情況發生。舉例來說：<code>nop</code>就寄生在<code>addi</code>上。詳情可以查看規格書</p>
</blockquote>

<p>接著使用 <code>parse-opcode</code> 這一個執行檔產生出相對應所撰寫編碼的十六進位表示。</p>

<pre><code class="language-c">cat opcodes opcodes-rvc-pseudo opcodes-rvc opcodes-custom | ./parse-opcodes -c | grep &quot;VFADD_S&quot;
</code></pre>

<p><img src="https://i.imgur.com/Gl3QMq2.png" alt="" /></p>

<blockquote>
<p>這邊是一個取巧的辦法，指印出所需要新增的那一個指令。當然你可以不使用 <code>grep</code> 直接輸出。</p>
</blockquote>

<p>將這個結果加入至 <code>riscv-tools/riscv-isa-sim/riscv/encoding.h</code> 。</p>

<h3 id="描述指令行為">描述指令行為</h3>

<p>所有行為的描述都建立在 <code>rsicv-tools/riscv-isa-sim/riscv/insn/[instruction name].h</code>。</p>

<p>實際上用於描述指令行為的語言是 c++，只不過 spike 用上了一堆 marco 讓它看起來很不像，這些 marco 主要是在替換調與 register 和 memory 互動的複雜性。多看幾次應該就可以感覺的出來這些 marco 實際上的行為。</p>

<p>一樣用 vfadd.s 作為例子</p>

<pre><code class="language-c">vreg_t rst;
vreg_t rs1 = VRS1;
vreg_t rs2 = VRS2;
int vl = STATE.vl;

for(int i=0; i&lt;vl; i++) {
    rst.f_data[i] = rs1.f_data[i] + rs2.f_data[i];
}
for(int i=vl; i&lt;MAXVL; i++) {
    rst.f_data[i] = 0;
}

WRITE_VRD(rst);
</code></pre>

<h3 id="註冊指令至spike">註冊指令至spike</h3>

<p>到 <code>riscv-tools/riscv-isa-sim/riscv/riscv.mk.in</code> 中，在<code>riscv_insn_list</code>下加入新的指令名稱。並且重新編譯一次 spike。</p>

<h3 id="測試新指令">測試新指令</h3>

<p>因為並沒有實際去修改編譯器，所以編譯程式的時候，編譯並不會自動生成剛剛新增的指令。而為了加入一個新的指令而重新編譯一次編譯器太花時間了。</p>

<blockquote>
<p>一次大概 30 分鐘。</p>
</blockquote>

<p>所以在這裡使用一個小技倆，可以繞過編譯器，直接加入新的指令至執行檔。這個技倆就是 <code>assembly inline</code>。</p>

<pre><code class="language-c">asm __volatile__ (&quot;.word [instruction encoding]\n&quot;);
</code></pre>

<p>這一個部份的關鍵就是要如何生成出正確的指令格式。關鍵如下：</p>

<ul>
<li>編碼</li>
<li>暫存器</li>
</ul>

<p>這部份過於繁雜，在此不具體描述，僅提供一些想法。</p>

<ul>
<li>先定義好所需要的變數，如此編譯器就會將這些變數分配給特定的暫存器</li>
<li>使用工具查看編譯器所產生的 <code>assembly</code> 看這些變數</li>
<li>自己轉換編碼，<code>bin to hex</code></li>
<li>重新編譯一次程式</li>
</ul>

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
