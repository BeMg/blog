<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BeMg</title>
    <link>https://bemg.github.io/blog/</link>
    <description>Recent content on BeMg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Mar 2020 11:40:01 +0800</lastBuildDate>
    
	<atom:link href="https://bemg.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Book Reading 2020 03</title>
      <link>https://bemg.github.io/blog/posts/book-reading-2020-03/</link>
      <pubDate>Tue, 10 Mar 2020 11:40:01 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/book-reading-2020-03/</guid>
      <description> 古地中海文明陷落的關鍵：公元前1177年 筷：怪談競演奇物語  </description>
    </item>
    
    <item>
      <title>Llvm Trick</title>
      <link>https://bemg.github.io/blog/posts/llvm-trick/</link>
      <pubDate>Mon, 19 Aug 2019 18:50:01 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/llvm-trick/</guid>
      <description>前言 LLVM 太多神秘的小技巧了，整理成一篇文章以外之後忘記。
本篇文章主要以需求導向，根據某個需求要如何用LLVM工具達成，
LLVM Tools Usage 啟用Subtarget 這裡以 RISC-V 為例。
llc --march=riscv32 --mattr=+M,+F file.ll Backend SDTypeProfile 一個 SDNode 的 Type，很多時候會發生 Instruction can not be select 的根本原因就是因為型態對不上。
// llvm/include/llvm/Target/TargetSelectionDAG.td // SDTypeProfile - This profile describes the type requirements of a Selection // DAG node. class SDTypeProfile&amp;lt;int numresults, int numoperands, list&amp;lt;SDTypeConstraint&amp;gt; constraints&amp;gt; { int NumResults = numresults; int NumOperands = numoperands; list&amp;lt;SDTypeConstraint&amp;gt; Constraints = constraints; } 第一個是回傳值，第二個是參數，第三個是說明需要的型態為何。
常用的型態紀錄如下
// SDTCisVT - The specified operand has exactly this VT.</description>
    </item>
    
    <item>
      <title>llvm_pointer_type</title>
      <link>https://bemg.github.io/blog/posts/llvm_pointer_type/</link>
      <pubDate>Sat, 01 Dec 2018 12:21:14 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/llvm_pointer_type/</guid>
      <description>LLVM pointer type 解析 寫個作業發現居然沒有對於 LLVM pointer type 的詳細說明，難怪沒有人要做 compiler，文件都那麼不友善。明明 pointer 是這麼常用的到東西。一堆 dereference 的星星。
本文基於C language 對於 llvm IR 的轉換進行介紹。
目錄   名詞定義
  pointer type
  reference
  dereference
  LLVM IR
  名詞定義 Pointer type 在C語言中，我們使用 pointer 會是一個指向某一個 address 的 variable。
int *p; int x; p = &amp;amp;x; Reference 每個變數都有值(value)跟位址(address)，pointer type 只是剛好 value 是某一個 address。所謂的 Reference 就是指用一個關鍵字去取得一個特定變數的address。
int *p; printf(&amp;#34;%p\n&amp;#34;, &amp;amp;p); dereference 這個操作是指 reference 的反向，如果可以從一個變數取得它的位址，那麼也可以從一個位址取得它的值。</description>
    </item>
    
    <item>
      <title>Sshfs</title>
      <link>https://bemg.github.io/blog/posts/sshfs/</link>
      <pubDate>Mon, 17 Sep 2018 13:55:00 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/sshfs/</guid>
      <description>sshfs 前言 這是一個與遠端檔案同步的解決方案，最大的特色為伺服器端不需要進行任何的設定。
功能上是可以在本地同步修改遠端的檔案或者文件，表現的手法是將遠端的資料夾視為一個本地的資料夾，這樣就可以直接像是在修改本地資料一樣修改位於遠端的資料。
ubuntu apt-get install sshfs sshfs [username]@[server ip]:[remote dir] [local dir] fusermount -u [local dir] 以上三個指令分別是代表安裝、使用與解除掛載。
windows 這個就沒有像 ubuntu 一樣方便的，需要一些進階的輔助程式。
 sshfs-win winfsp siriKai  前兩個是必須的，第三個為GUI的操控界面用起來可以更的心應手。
都裝一裝，開 siriKai 起來進行設定。
 create volume  sshfs  remote address -&amp;gt; 就是 [usernmae]@[server ip]:[remote dir] Mount point path -&amp;gt; 隨便選一個，沒有它會建立     Add and done Favorites  點你剛剛加入的volume 輸入密碼    </description>
    </item>
    
    <item>
      <title>Vector Architecture Notes 3 - x86</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-3/</link>
      <pubDate>Sun, 02 Sep 2018 17:57:41 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-3/</guid>
      <description>前言 對於 Vector Architecture 做一下筆記。對於各種不同的 ISA 的 vector extension 進行比較。
 computer architecture a quantitative approach 課本筆記 -&amp;gt; 實際上就是 VMIPS riscv vector extension tutorial x86  MMX SSE AVX   arm ISA vector extension  X86 SIMD history 這個系列指令是由 intel 所開發，順序如下：
MMX -&amp;gt; SSE -&amp;gt; AVX 皆是基於前者再進行擴充。分類上皆是 SIMD 指令集。版本一大堆。
 MMX (Matrix Math Extension) SSE (Streaming SIMD Extension)  2, 3, 4, 4.1, 4.2   AVX (Advanced Vector Extension)  2, 512    至於彼此之間有沒有被取代的問題還需要再研究。</description>
    </item>
    
    <item>
      <title>What Is Fixed Point</title>
      <link>https://bemg.github.io/blog/posts/what-is-fixed-point/</link>
      <pubDate>Fri, 31 Aug 2018 12:30:33 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/what-is-fixed-point/</guid>
      <description>前言 因為在閱讀 ISA 的文件時，對於常常出現的名詞不是十分清楚。主要將重點把在：
 fixed point float point  Fixed Point 結構 fixed point 由兩個部份組合
 Integer part Scaling factor part  通常用 10 或者 2 的指數形式表達     例如：1.23 在 fixed point 中可以被表達為，1230 與 1/1000。
 操作 如果要轉換從一個 scaling factor 到另外一個不相同的 scaling factor。最簡單的方法就是 fixed point 還原成真正的數值，然後再 scaling 一次。我們可以定義一下各種數值，然後用數學公式來表示這種情況。
 令 I 為原始值的 Integer part 令 N 為 目標值 令 R 為原始值的 scaling factor 令 S 為目標值的 scaling factor  $$ N = I * \frac{R}{S} $$</description>
    </item>
    
    <item>
      <title>Go goroutine</title>
      <link>https://bemg.github.io/blog/posts/go-waitgroup/</link>
      <pubDate>Mon, 27 Aug 2018 11:16:03 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/go-waitgroup/</guid>
      <description>前言 這篇文章會包含 goroutine 的一些用法與需要注意的要點。
在這個問題上，我們需要釐清的重點在於
 goroutine channel select waitgroup timeout  goroutine是 golang 中一個重要的 feature，概念上就是從程式語言的層次上支援 coroutine 的功能。可以在低成本(不論是硬體或者是程式撰寫的部份)的情況下大量的使用平行化。
從最近使用的感想上來說，可以理解為，被指定由goroutine方法執行的程式區塊，是被直接丟進另外一個task pool 中等待電腦去執行它。至於 golang 是如何實現讓這些大量的 task 去榨乾所有的運算支援大概可以再寫一篇文章來討論。
被放出去的執行的程式，我們可以使用 channel 作為傳遞資料的管道，也可以作為一種 wait 的方法。當有多個 coroutine 同時在背景執行時，且每個 coroutine 個別的結果需要分別處理時，就可以利用 select 去接 channel 並且分開來處理。
當不需要分開處理又需要等待所有的coroutine執行完畢。就簡單的使用 sync.waitgroup 去執行與等待。
在每個執行的程式之中，有些程式可能會卡死，原因很多，像是網路不通阿。要取得的東西太大&amp;hellip;總之，如果讓整個程式就卡在這裡的話，就沒有加速的意義了。所以需要一個timeout來限制最長的執行時間，如果時間到 coroutine 卻還沒有執行完成，那就進行其他的處理。
範例 Goroutine and Channel func main() { c1 := make(chan int) go func () { c1 &amp;lt;- do_something_computer1() }() c2 := make(chan int) go func () { c2 &amp;lt;- do_something_computer2() }() result := &amp;lt;-c1 + &amp;lt;-c2 }  調用 gooutine 的關鍵字為 go 只能加在一個 method/function 調用之前(待驗證)。用途就是將這個 func 令其在丟進 task pool。 channel 為goroutine之間溝通的管道，我們可以利用其來達成 wait 的效果。  channel 的宣告為在變數之前加上 chan，例：chan int channel 的使用上會用 &amp;lt;-，由變數的位置來決定是取用還是寫入   系統會等到c1與c2都執行完成才會結束。   如果不 wait，執行過程不會等待 goroutine 執行結束與否就直接 exit</description>
    </item>
    
    <item>
      <title>Vector Architecture Notes SIMDandGPU</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-simdandgpu/</link>
      <pubDate>Sat, 18 Aug 2018 20:55:53 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-simdandgpu/</guid>
      <description>前言 對於現行的 SIMD(Single instruction multiply data) 架構進行比較，主要有以下：
 Vector instructions SIMD instructions GPU  主要的內容取至 computer architecture a quantitative approach chp4.1-4
Vector instructions 請看這篇
SIMD instructions for multimedia 此處的 SIMD instruction 主要是為了 Multimedia 所設計。跟現實中所謂的 SIMD 的定義有一些微妙的差異。如果直接講結論的話，應當可以是這一類 SIMD 為 vector instruction 的 subset。是為了硬體的複雜度與效能上做出的取捨。
 大多數的 graphics system 會分別使用 8-bits 去表達三原色，在使用一個額外的 8-bits 表達透明度。剛好用完一個 32-bits。
audio sample (聲音取樣) 通常被表達為 8-bits 或者 16-bits
 知名的 SIMD for multimedia
 MMX SSE AVX   上述皆是 x86 下的產物，似乎可以額外做一篇筆記了。</description>
    </item>
    
    <item>
      <title>Vector Architecture Notes 2 - RISC-V Vector extension</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-2/</link>
      <pubDate>Sun, 05 Aug 2018 22:49:37 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-2/</guid>
      <description>前言 對於 Vector Architecture 做一下筆記。對於各種不同的 ISA 的 vector extension 進行比較。
 computer architecture a quantitative approach 課本筆記 -&amp;gt; 實際上就是 VMIPS riscv vector extension tutorial arm ISA vector extension  RISC-V vector extension 規格還在制定中，只有一些 draft 等級的東西在，姑且暫時用這些資料作為參考。
 硬體架構 指令集分類 範例   也就是說很有可能之後通通改掉，直接白研究了 QQ
 Complement vector extension instruction 根據[2]，我們可以列出所有的指令如下：
 operation  用途   body  指令的代號   encoding  是否已經被編碼 是某編碼是根據這份資料   instruction detail  各種派生指令    Vector Memory Instructions    Operation Body Encoding Instructions Detail     vector load vl Yes vlb, vlbu, vlh, vlhu, vlw, vlwu, vld, vflh, vflw, vfld   vector load, strided vls Yes vlsb, vlsbu, vlsh, vlshu, vlsw, vlswu, vlsd, vflsh, vflsw, vflsd   vector load, indexed (gather) vlx Yes vlxb, vlxbu, vlxh, vlxhu, vlxw, vlxwu, vlxd, vflxh, vflxw, vflxd   vector store vs Yes vsb, vsh, vsw, vsd   vector store, strided vss Yes vssb, vssh, vssw, vssd   vector store, indexed (scatter) vsx Yes vsxb, vsxh, vsxw, vsxd   vector store, indexed, unorder vsxu No vsxub, vsxuh, vsxuw, vsxud    Vector Integer Instructions    Operation Body Encoding Instructions     add vadd Yes vadd, vaddi, vaddw, vaddiw   subtract vsub Yes vsub, vsubw   multiply vmul No vmul, vmulh, vmulhsu, vmulhu   widening multiply ?</description>
    </item>
    
    <item>
      <title>Vector Architecture Notes 1 - VMIPS</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-1/</link>
      <pubDate>Sun, 05 Aug 2018 12:07:48 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-1/</guid>
      <description>前言 對於 Vector Architecture 做一下筆記。對於各種不同的 ISA 的 vector extension 進行比較。
 computer architecture a quantitative approach 課本筆記 -&amp;gt; 實際上就是 VMIPS riscv vector extension tutorial arm ISA vector extension  VMIPS VMIPS 是課本作者針對於 MIPS，增加 vector instruction 的擴增板。描述了大致上的硬體架構與各種針對於效能議題上的探討。
 硬體架構 指令集分類 範例 術語 改進  硬體架構  Vector register  預設有 8 個 vector register 每個 register 有 64 個 element，每個 element 寬度為 64 bits   Vector functional units  專門對 vector register 進行加法、減法、乘法、除法、邏輯運算的元件。 可以被 pipelined。  這一點後面的章節會提到。就是可以先執行在 vector register 中的第一個 element，而不用等到全部的 element 都讀入 register 才開始執行。     Vector load/store units  在 register 與 memory 之間讀入/寫入資料。 一樣是可以被 pipelined。 也支援 scalar 的 load/store   scalar register  就是 MIPS 中原本的那些 register。    在此還有兩個特殊的 register 留待後續討論。</description>
    </item>
    
    <item>
      <title>Introduction to Spike</title>
      <link>https://bemg.github.io/blog/posts/introduction-to-spike/</link>
      <pubDate>Wed, 01 Aug 2018 10:32:07 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/introduction-to-spike/</guid>
      <description>前言 最近花了大概兩個禮拜研究了 RISCV 的官方模擬器 (riscv-isa-sim) Spike。
內容包含
 安裝 基本使用 如何加入新的指令  安裝 在使用 spike 之前，需要安裝 riscv-tools，所需要的工具大致如下
 riscv-gnu-toolchain: RISC-V cross-compiler riscv-fesvr: a &amp;ldquo;front-end&amp;rdquo; server that services calls between the host and target processors on the Host-Target InterFace riscv-isa-sim: ISA simulator, as kown as spike riscv-opcodes: the enumeration of all RISC-V opcodes executable by the simulator riscv-pk: a proxy kernel that services system calls generated by code built and linked with the RISC-V Newlib port riscv-tests: a set of assembly tests and benchmarks  粗體的部份是使用 spike 會需要理解的部份。</description>
    </item>
    
    <item>
      <title>Go Notes</title>
      <link>https://bemg.github.io/blog/posts/golang-notes/</link>
      <pubDate>Tue, 31 Jul 2018 20:38:40 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/golang-notes/</guid>
      <description>前言 簡單的紀錄一下 golang
 基本語法 爬蟲相關 使用心得  基本語法 // 註解的形式與c相同，雙重單斜線為單行註解。 /* 此為多行註解 */ // 使用外部函式庫 // 備註：沒有用到卻宣告會導致錯誤。 import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;strconv&amp;#34; ) // 變數宣告 // 一樣，沒有使用卻宣告會導致錯誤。 var a [type] = value a := value // 最常用 var a = value // 據說會自行推理型態。  // 陣列宣告 var a [5]int; // 切片(slice)宣告 var a []int = {1, 2 ,3, 4}; a = append(a, 5); a[1:2] // get [2];  // 就是 c 的 printf // golang 習慣函數的頭一個字母為大寫，似乎是隱藏了一些慣例，只要是首字大寫變為 public method 或者 variable。 // ^ 待確認 fmt.</description>
    </item>
    
    <item>
      <title>Cmder Notes</title>
      <link>https://bemg.github.io/blog/posts/cmder-notes/</link>
      <pubDate>Fri, 06 Jul 2018 13:04:56 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/cmder-notes/</guid>
      <description>前言 在 windows 系統底下，cmd(命令提示字元)是類似於 unix bash 的功能。可是 cmd 看起來實在是不太友善，無論是用法與字體，他的指令用法也是與 unix 有很大的差異。所以在於 windows 系統下，我通常會使用有 gui 的應用程式進行操作(例：git&amp;hellip;)。
 一點差異：顯示當其目錄的檔案 ls vs dir
 不過大概在 2016 開始，微軟讓 windwos 10 可以支援 linux 的子系統，被稱為 bash on windows，裝起來就很像一個只有 bash 的虛擬機器。
cmder 就是在 cmd 上面在套一層看起來很漂亮的畫面。在搭配上 bash on windows。期許可以用起來感覺像是真的在 linux 下指令。
安裝 bash on windows  開啟 控制台-開啟或關閉windows功能-適用於windows的linux子系統 下載 windows store 中的 ubuntu 啟動cmd 輸入bash -&amp;gt; 初次使用要進行安裝 此後只要輸入 bash 就可以啟動  cmder cmder 不用安裝，它就是一個資料夾，可以用dropbox還是google driver進行多台電腦同步。
 去官網下載 啟動 /bin/cmder.</description>
    </item>
    
    <item>
      <title>Selenium notes</title>
      <link>https://bemg.github.io/blog/posts/selenium-intro/</link>
      <pubDate>Sat, 07 Apr 2018 16:22:57 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/selenium-intro/</guid>
      <description>前言 對於使用javascript動態產生的網頁來說，單純的抓取html會缺失許多資訊。我們可以透過selenium執行javascript，生成我們所需要的資訊。
selenium原本是被設計來進行自動化測試的，但是我們只需要它執行javascript的功能。
安裝 pip3 install selenium 在此使用chrome作為範例。
到官網下載chromedrive。並且將其加入至PATH中，或者在使用時指定其位置。
使用 from selenium import webdriver from selenium.webdriver.chrome.options import Options # 加入參數 chrome_options = Options() chrome_options.add_argument(&amp;#34;--headless&amp;#34;) # 啟動 drive = webdriver.Chrome(chrome_options=chrome_options) # 讀取網頁 drive.get(url) # 取得source drive.page_source </description>
    </item>
    
    <item>
      <title>Elasticsearch 筆記</title>
      <link>https://bemg.github.io/blog/posts/elastic-notes/</link>
      <pubDate>Wed, 28 Feb 2018 13:22:58 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/elastic-notes/</guid>
      <description>elasticsearch 簡介 基於java，所以要先裝java &amp;gt;= 8。跑起來之後長的很像一台server，並且透過REST API進行資料的增減與搜尋的query。
傳送給elastic的資料格式以JSON為主。
elastic search 運作起來很像是database 下面簡單列出與database之間的對應關係。
 Node &amp;lt;-&amp;gt; DB server Index &amp;lt;-&amp;gt; database Type &amp;lt;-&amp;gt; Table document &amp;lt;-&amp;gt; row Field &amp;lt;-&amp;gt; column  使用 不經修改，預設elasticsearch會使用localhost:9200作為他的接口。所以可以藉由這個路徑進行操作。
 官方推薦在terminal使用curl進行操作
  查看目前有的index  GET /_cat/indices?v health status index uuid pri rep docs.count docs.deleted store.size pri.store.size yellow open hw1 l8nmMoxjSYypWv0LZ0IWpA 5 1 530278 0 1.2gb 1.2gb  建立一個index  mapping = &#39;&#39;&#39; { &amp;quot;settings&amp;quot; : { &amp;quot;number_of_shards&amp;quot; : 1 }, &amp;quot;mappings&amp;quot; : { &amp;quot;news&amp;quot; : { &amp;quot;properties&amp;quot; : { &amp;quot;body&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;text&amp;quot; }, &amp;quot;image_link&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}, &amp;quot;keyword&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}, &amp;quot;post_time&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}, &amp;quot;title&amp;quot; : {&amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;}, &amp;quot;url&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;} } } } } &#39;&#39;&#39; es = Elasticsearch(timeout=30, max_retries=10, retry_on_timeout=True) es.</description>
    </item>
    
    <item>
      <title>LLVM 筆記 (更新中)</title>
      <link>https://bemg.github.io/blog/posts/llvm-notes/</link>
      <pubDate>Mon, 26 Feb 2018 19:03:58 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/llvm-notes/</guid>
      <description>目錄  前言 架構 實驗 參考資料  前言 LLVM是一個完整的編譯器基礎建設(compiler infrastructure)，與GNU GCC相比，最大的差異在於大量的將compile的過程高度模組化，可以進行任意的抽換。從 source code 到 machine code，每一個階段都有相對應的module。
本篇文章雖然以LLVM 為標題，可是實際上多半都在整理編譯器的相關知識，畢竟LLVM大部分都是在實做這些編譯器的技術。
版本  OS: Ubuntu 16.04 LLVM: 7.0 Clang: 7.0 GCC: 5.4  安裝 從原始碼開始從頭編譯
apt-get update apt-get install -y sudo subversion python-dev g++ cmake svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm cd llvm/tools svn co http://llvm.org/svn/llvm-project/cfe/trunk clang cd ../.. cd llvm/tools/clang/tools svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra cd ../../../.. cd llvm/tools svn co http://llvm.org/svn/llvm-project/lld/trunk lld cd ../.. cd llvm mkdir build cd build cmake -G &amp;#34;Unix Makefiles&amp;#34; -DCMAKE_BUILD_TYPE=Release .</description>
    </item>
    
    <item>
      <title>Fcitx 輸入法與新酷音</title>
      <link>https://bemg.github.io/blog/posts/fcitx-input-method/</link>
      <pubDate>Sun, 25 Feb 2018 12:04:05 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/fcitx-input-method/</guid>
      <description>在ubuntu底下有內建輸入法ibus，但是其使用上的體驗與在windows上的新注音輸入法有比較大的隔閡，用起來不是很習慣。在尋找更好的輸入法時，有嘗試過gcin與Rime。下面分別說說他們的缺點。
 gcin  這個輸入法沒有辦法自動學習正確的詞彙，以及一開始預設的字典挺小的。用起來時常會打錯字，需要細心的一一修正，用起來不是很方便。   rime  在字典的自動修正上與新詞彙的學習上都較為良好，但是在輸入法的使用上，rime並不會限制你的輸入，也就是說就算你輸入了一連串完全沒有待選字的注音，它還是會讓你繼續輸入，很大程度上要求你字字輸入清楚，用起來壓力很大。    fcitx 於是乎我就找到了另外一款兼具gcin輸入方式與rime的詞彙精準度的輸入法 新酷音。下面簡單的介紹如何安裝與使用。
安裝 sudo apt-get install fcitx fcitx-chewing fcitx-anthy  fcitx 是輸入法框架 chewing 是新酷音 anthy 是一款日文輸入法  設定 System setting -&amp;gt; language support -&amp;gt; language tab -&amp;gt; Keyboard input method system -&amp;gt; 調整為fcitx
如果沒有跳出fctix，請重新登入系統。
開啟 fcitx 的 configue 加入，fcitx-chewing與fcitx-anthy。
操作  ctrl-space fcitx的啟用與關閉  常用於切換成英文輸入   ctrl-shift 在fcitx啟動的情況下，循環切換設定的輸入法  </description>
    </item>
    
    <item>
      <title>閱讀列表</title>
      <link>https://bemg.github.io/blog/posts/reading-list/</link>
      <pubDate>Tue, 20 Feb 2018 13:46:39 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/reading-list/</guid>
      <description>紀錄一下看過的書，心有餘力會新增對於每本書的評價。
多少會有暴雷的風險，如果有這方面的顧慮就別看了。
歷史類  海都物語  描寫威尼斯共和國從建國到亡國的興亡史，很明顯的看得出作者對於威尼斯有許多個人情感存在，各種對於威尼斯來說負面的歷史事件都會勇於辯護(例：第四次十字軍東征，威尼斯用計驅使聯軍去攻打君士坦丁堡，順利扶持支持威尼斯的政權;後期，威尼斯對於鄂圖曼土耳其的壓迫，動不動就想要暗殺其領袖，真不知道作者前面描寫那麼多威尼斯因為貿易需要所以兼容並蓄是為了什麼，最後還不是要動刀動槍)，不過也在其中得到了一些從國中以來的困惑。當初國中世界史章節的封面有一張十字軍攻陷君士坦丁堡的畫，可是在於國中歷史課本之中根本沒有去解釋有著大義的十字軍為什麼需要去攻陷有著東羅馬帝國的首都。    小說  文學少女  拿許多知名的經典小說的情節去進行重新的演繹，不過在沒有看過採用的經典的讀者而言，或多或少會失去部份的樂趣。表面上是對於經典情節的重新詮釋，深處其實在於主角的心理陰影(「心葉，你一定不懂吧。」)與女主角布局到最後一集的深意，本傳前後有8本，不算少，看的到是挺輕鬆的，沒有壓力與需要重覆理解的章節。   大典  一本用近現代科技去寫的科幻小說，前面看起來鋪陳不錯，可是一到中間的轉折看起來就很勉強。先不論其過於牽強的情節，這本書想要告訴讀者的主題是，集權國家藉由科技的力量控制國家的極致後，會發生什麼事情。根據作者推想之後得出的結論是，操作科技的技術人員會成為最大的漏洞，而集權也會因為這份過強的科技輕易的覆滅。   吃掉死神的少女  整體看來，著實過於著重在對於戰爭殘酷的描寫，用於去陪襯主角的瘋狂與已經不屬於人的心態。整體的步調顯得沉悶，我給予的評價並沒有如同網路上的評價一樣高。過度描寫的血腥場景只會造成閱讀的障礙。相較之下，對於其他配角的描寫就出色了許多，一如主角的副官在尋找一個可以用來信仰的英雄;軍官為了家族的榮光不惜動用各種狡計;走頭無路的國王對於臣子的寬容。比起主角都更加的像個人。   盜夢偵探 新本格魔法少女莉絲佳  因為作者是西尾維新，所以一開始就有預感這不會是什麼正常的魔法少女，主角群肯定都是一些人格異常的傢伙。實際看下來也實際如此。雖然主角群人格異常，可是並沒有脫離古典魔法少女的公式(事件-&amp;gt;嘗試解決-&amp;gt;失敗-&amp;gt;交給魔法少女變身作結)，可是至今這個系列只有兩本，感受不到西尾維新的誠意阿。   黑暗的左手  科幻。虛構的星球。虛構的新人類。移除了人與人之間於性別的隔閡。   阿特拉斯聳聳肩  這本書是遊戲 bioshock 的靈感來源，可以說是這本小說的續集，在演示如果這個所謂有能力的人所建構出來的烏托邦成真其後續的結果。原書鼓吹自由主義，右派的極致。相信個人的努力遠超過環境的影響。   駭客與畫家  我認為過譽了。全書有將近一半的篇幅都在吹捧作者在成立公司期間的豐功偉業。另外一半在談作者所認知的世界應該是怎麼樣運作的。    其他非虛構  老科技的全球史 娛樂至死 : 追求表象﹑歡笑和激情的電視時代  </description>
    </item>
    
    <item>
      <title>英文學習</title>
      <link>https://bemg.github.io/blog/posts/learn-english/</link>
      <pubDate>Tue, 20 Feb 2018 13:46:33 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/learn-english/</guid>
      <description>紀錄一下到目前為止對於英文學習的心得與方法。
前言 英文對我來說很困難，從小學就有的科目而言，長達十幾年的學習。依舊仍然停滯在沒有辦法自在運用的程度。
直到近期才真正的正視英文能力的養成。故在此紀錄我從2017/07開始至今的英文學習歷程。希望可以給有相同困擾的人一個努力的方向。
本文 目標 我對於學習英文的第一階段目標是
 閱讀原文文章 看英文影片  也就是聽與讀的部份。
在技術的方面，由英文所撰寫的第一手文章，其數量與正確度比起經過翻譯的第二手文章來說，都高上許多。
故先以這兩項能力為目前的目標。
閱讀 閱讀所使用的材料多半取自於新聞與技術文章。而在閱讀的過程中，我意識到了英文能力低落的關鍵，單字量完全不足，在一句英文句子有高達三個單字完全無法理解的情況下，要理解其想要傳達的含意簡直是癡人說夢。
聽力 我用來練習的影片多半來自於youtube
 Extra Credits  這個頻道有很多的關於歷史與遊戲機制設計的影片。    很遺憾的是，很多時候沒有辦法聽懂內容跟單字量有相當高的相關，根本就不理解那個單字，是要怎麼可以從一連串的發音中辨識出來想要提供的含意。
 根據我一個英文很好的同學表示，裡面的單字水準真的是比較高。或許該找一下有沒有比較符合我這個英文水準的好頻道。
 現階段的努力 總結上述的問題，充實我的英文單字量是刻不容緩的工作。
起先我拿出了我塵封已久的高中7000單字書，步上了過去高中的單字學習法。重溫了高中的單字學習的過程中，我進行了幾項對於方法的修正。我不再要求可以對於英文單字每一個字母都可以熟記，雖然因為在於高中時期需要熟記拼字才可以有辦法成功的寫英文考卷。
 很快的，7000單字都已經被我輸入到anki之中了，現在就是見識它的威力的時刻。
 我使用了一些輔助的被單字軟體
 anki  免費的，可以用xml或者css客製化字卡的外觀。並且遵循著學習遺忘曲線進行單字的複習。 我現在的設置為50個新單字 250 複習的單字    更新  2018/03/27  得到了一些新的想法，對於單字卡來說。正面：一個生字搭配一個例句，背面：單字的中文解釋。這樣的搭配可以有效的記憶中文解釋，而且這個搭配也是正常閱讀的時候所擁有的上下文。    </description>
    </item>
    
  </channel>
</rss>