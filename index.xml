<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BeMg</title>
    <link>https://bemg.github.io/blog/</link>
    <description>Recent content on BeMg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 07 Apr 2018 16:22:57 +0800</lastBuildDate>
    
        <atom:link href="https://bemg.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Selenium notes</title>
      <link>https://bemg.github.io/blog/posts/selenium-intro/</link>
      <pubDate>Sat, 07 Apr 2018 16:22:57 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/selenium-intro/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;對於使用javascript動態產生的網頁來說，單純的抓取html會缺失許多資訊。我們可以透過selenium執行javascript，生成我們所需要的資訊。&lt;/p&gt;

&lt;p&gt;selenium原本是被設計來進行自動化測試的，但是我們只需要它執行javascript的功能。&lt;/p&gt;

&lt;h2 id=&#34;安裝&#34;&gt;安裝&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install selenium
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此使用chrome作為範例。&lt;/p&gt;

&lt;p&gt;到&lt;a href=&#34;https://sites.google.com/a/chromium.org/chromedriver/getting-started&#34;&gt;官網&lt;/a&gt;下載chromedrive。並且將其加入至PATH中，或者在使用時指定其位置。&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from selenium import webdriver
from selenium.webdriver.chrome.options import Options

# 加入參數
chrome_options = Options()
chrome_options.add_argument(&amp;quot;--headless&amp;quot;)

# 啟動
drive = webdriver.Chrome(chrome_options=chrome_options)

# 讀取網頁
drive.get(url)

# 取得source
drive.page_source


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Elasticsearch 筆記</title>
      <link>https://bemg.github.io/blog/posts/elastic-notes/</link>
      <pubDate>Wed, 28 Feb 2018 13:22:58 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/elastic-notes/</guid>
      <description>

&lt;h1 id=&#34;elasticsearch&#34;&gt;elasticsearch&lt;/h1&gt;

&lt;h2 id=&#34;簡介&#34;&gt;簡介&lt;/h2&gt;

&lt;p&gt;基於java，所以要先裝&lt;code&gt;java &amp;gt;= 8&lt;/code&gt;。跑起來之後長的很像一台server，並且透過REST API進行資料的增減與搜尋的&lt;code&gt;query&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;傳送給elastic的資料格式以&lt;code&gt;JSON&lt;/code&gt;為主。&lt;/p&gt;

&lt;p&gt;elastic search 運作起來很像是database 下面簡單列出與database之間的對應關係。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node &amp;lt;-&amp;gt; DB server&lt;/li&gt;
&lt;li&gt;Index &amp;lt;-&amp;gt; database&lt;/li&gt;
&lt;li&gt;Type &amp;lt;-&amp;gt; Table&lt;/li&gt;
&lt;li&gt;document &amp;lt;-&amp;gt; row&lt;/li&gt;
&lt;li&gt;Field &amp;lt;-&amp;gt; column&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;不經修改，預設&lt;code&gt;elasticsearch&lt;/code&gt;會使用&lt;code&gt;localhost:9200&lt;/code&gt;作為他的接口。所以可以藉由這個路徑進行操作。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;官方推薦在&lt;code&gt;terminal&lt;/code&gt;使用&lt;code&gt;curl&lt;/code&gt;進行操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;查看目前有的&lt;code&gt;index&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;GET /_cat/indices?v
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   hw1   l8nmMoxjSYypWv0LZ0IWpA   5   1     530278            0      1.2gb          1.2gb
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;建立一個index&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;mapping = &#39;&#39;&#39;
{
    &amp;quot;settings&amp;quot; : {
        &amp;quot;number_of_shards&amp;quot; : 1
    },
    &amp;quot;mappings&amp;quot; : {
        &amp;quot;news&amp;quot; : {
            &amp;quot;properties&amp;quot; : {
                &amp;quot;body&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;text&amp;quot; },
                &amp;quot;image_link&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;},
                &amp;quot;keyword&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}, 
                &amp;quot;post_time&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;},
                &amp;quot;title&amp;quot; : {&amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;},
                &amp;quot;url&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}
            }
        }
    }
}
&#39;&#39;&#39;
es = Elasticsearch(timeout=30, max_retries=10, retry_on_timeout=True)
es.indices.create(index=&#39;hw2&#39;, ignore=400, body=mapping)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;重點在於制定特定的mapping，如果都交給elastic自己管理的話，極有可能會發生錯誤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;加入一筆index&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;curl -XPOST &#39;locjson&#39;t:9200/test/news&#39; -d &amp;quot;{ \&amp;quot;title\&amp;quot;: \&amp;quot;yee\&amp;quot;, \&amp;quot;body\&amp;quot;: 1234 }&amp;quot; -H &#39;Content-Type: application/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;_index&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;_type&amp;quot;:&amp;quot;news&amp;quot;,&amp;quot;_id&amp;quot;:&amp;quot;LCmeGWIBVfCh6W9Xihub&amp;quot;,&amp;quot;_version&amp;quot;:1,&amp;quot;result&amp;quot;:&amp;quot;created&amp;quot;,&amp;quot;_shards&amp;quot;:{&amp;quot;total&amp;quot;:2,&amp;quot;successful&amp;quot;:1,&amp;quot;failed&amp;quot;:0},&amp;quot;_seq_no&amp;quot;:0,&amp;quot;_primary_term&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;如果不填入id的話，它會自動給一個隨機的id&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;移除整個index&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;DELETE /index_name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -XDELETE localhost:9200/[indexname]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;執行多筆指令(bulk)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;curl -XPOST &#39;localhost:9200/_bulk&#39; -d {query}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;一次只加入一筆資料速度挺慢的，初步推測是因為頻繁進行硬碟I/O的緣故，故一次新增多筆index。有效的解決這個問題。&lt;/p&gt;

&lt;p&gt;請小心，bulk不會因為單一筆query錯誤而傳出錯誤訊息，建議先使用小資料進行測試。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;elasticsearch-py&#34;&gt;elasticsearch-py&lt;/h2&gt;

&lt;p&gt;網路上有人將上訴的&lt;code&gt;REST API&lt;/code&gt;，包裝成python的&lt;code&gt;module&lt;/code&gt;。所以可以藉由此套件對elastic進行操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from elasticsearch import Elasticsearch
es = Elasticsearch()

# 我只有使用到兩個指令 bulk, search

es.bulk(body=action)
es.search(index=&#39;hw1&#39;, body={
     &amp;quot;query&amp;quot;: {

     &amp;quot;multi_match&amp;quot;: {

     &amp;quot;query&amp;quot; : keyword,

     &amp;quot;fields&amp;quot; : \[&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;\]
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json-操作&#34;&gt;JSON 操作&lt;/h2&gt;

&lt;p&gt;由於elasticsearch多使用JSON傳遞資料，在此紀錄一下一些常用的操作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寫入JSON到檔案&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(filename, &amp;quot;w&amp;quot;) as f:
    json.dump(data, f, ensure_ascii=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;ensure_ascii -&amp;gt; 設定為False，中文字才會顯示正常，不然會變成一串不是給人看的英文與數字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;讀取JSON從檔案&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(filename, &amp;quot;r&amp;quot;) as f:
    data = json.load(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;從object生成JSON&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;j = json.dumps(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;從JSON字串生成object&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = json.loads(j)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;從原始資料到前端&#34;&gt;從原始資料到前端&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;從原始資料到JSON檔&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import json
import glob

filename = glob.glob(&amp;quot;ettoday*.rec&amp;quot;)

data = \[\]
for fn in filename:
    cnt = 0
    with open(fn, &amp;quot;r&amp;quot;) as f:
        while True:
            cnt += 1
            pos = f.tell()
            useless = f.readline()
            url = f.readline()
            url = url\[3:\]
            url = url.strip(&#39;\\n&#39;)
            title = f.readline()
            title = title\[3:\]
            title = title.strip(&#39;\\n&#39;)
            useless = f.readline()
            maintext = f.readline()
            maintext = maintext.strip()
            after_pos = f.tell()
            print(&amp;quot;{}: {}&amp;quot;.format(fn, cnt))
            \# print(&amp;quot;{}:{}:{}&amp;quot;.format(url, title, maintext))
            if pos == after_pos:
                break
            else:
                data.append({
                    &#39;url&#39;:url, 
                    &#39;title&#39;:title, 
                    &#39;body&#39;:maintext})

with open(&#39;news.json&#39;, &amp;quot;w&amp;quot;) as f:
    json.dump(data, f, ensure_ascii=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;從json讀取進elastic&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from elasticsearch import Elasticsearch
import json

with open(&#39;./news_data/news.json&#39;) as f:
    Data = json.load(f)

es = Elasticsearch()
    
action = &#39;&#39;
cnt = 0
for data in Data:
    query = &#39;{&amp;quot;index&amp;quot;: {&amp;quot;\_index&amp;quot;: &amp;quot;hw1&amp;quot;, &amp;quot;\_type&amp;quot;: &amp;quot;news&amp;quot;}}\\n&#39; + json.dumps(data, ensure_ascii=False)
    action += query + &#39;\\n&#39;
    cnt += 1
    print(cnt)
    if cnt % 1000 == 0:
        es.bulk(body=action)
        action = &#39;&#39;

es.bulk(body=action)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;對elastic執行query&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def query(keyword): 
    es = Elasticsearch() 
    tmp = es.search(index=&#39;hw1&#39;, body={ &amp;quot;query&amp;quot;: { &amp;quot;multi_match&amp;quot;: { &amp;quot;query&amp;quot; : keyword, &amp;quot;fields&amp;quot; : [&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;] } } }) 
    tmp = tmp[&#39;hits&#39;][&#39;hits&#39;] 
    res = [] 
    for i in tmp: 
        res.append(i[&#39;_source&#39;]) 
    return res
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LLVM 筆記 (更新中)</title>
      <link>https://bemg.github.io/blog/posts/llvm-notes/</link>
      <pubDate>Mon, 26 Feb 2018 19:03:58 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/llvm-notes/</guid>
      <description>

&lt;h2 id=&#34;目錄&#34;&gt;目錄&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;架構&lt;/li&gt;
&lt;li&gt;實驗&lt;/li&gt;
&lt;li&gt;參考資料&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;LLVM是一個完整的編譯器基礎建設(compiler infrastructure)，與&lt;code&gt;GNU GCC&lt;/code&gt;相比，最大的差異在於大量的將compile的過程高度模組化，可以進行任意的抽換。從 source code 到 machine code，每一個階段都有相對應的module。&lt;/p&gt;

&lt;p&gt;本篇文章雖然以LLVM 為標題，可是實際上多半都在整理編譯器的相關知識，畢竟LLVM大部分都是在實做這些編譯器的技術。&lt;/p&gt;

&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Ubuntu 16.04&lt;/li&gt;
&lt;li&gt;LLVM: 7.0&lt;/li&gt;
&lt;li&gt;Clang: 7.0&lt;/li&gt;
&lt;li&gt;GCC: 5.4&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安裝&#34;&gt;安裝&lt;/h2&gt;

&lt;p&gt;從原始碼開始從頭編譯&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get update
apt-get install -y sudo subversion python-dev g++ cmake
svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
cd ../..
cd llvm/tools/clang/tools
svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra
cd ../../../..
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/lld/trunk lld
cd ../..
cd llvm
mkdir build
cd build
cmake -G &amp;quot;Unix Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release ..
make
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;架構&#34;&gt;架構&lt;/h2&gt;

&lt;h3 id=&#34;compiler-架構&#34;&gt;compiler 架構&lt;/h3&gt;

&lt;p&gt;在常見的compiler中，常見這類三段式的設計。
&lt;img src=&#34;https://i.imgur.com/miah8lO.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FrontEnd

&lt;ul&gt;
&lt;li&gt;將Source code 轉換為 IR or AST&lt;/li&gt;
&lt;li&gt;包含lexer、parser&lt;/li&gt;
&lt;li&gt;lexer： Regular Expression&lt;/li&gt;
&lt;li&gt;parser：Context-free grammar -&amp;gt; ANTLR 之類的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimizer

&lt;ul&gt;
&lt;li&gt;針對於IR進行最佳化，以追求更快的效能或者節省資源。&lt;/li&gt;
&lt;li&gt;在有中間語言的情況下，不需要針對每一種target language撰寫優化。&lt;/li&gt;
&lt;li&gt;也不需要撰寫多種不同的語言轉換。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BackEnd

&lt;ul&gt;
&lt;li&gt;將IR 轉換為 target language&lt;/li&gt;
&lt;li&gt;instruction selection&lt;/li&gt;
&lt;li&gt;register allocation&lt;/li&gt;
&lt;li&gt;instruction scheduling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而 LLVM 也是按照這三個階段的 compiler 設計為基準開發而成。&lt;/p&gt;

&lt;h3 id=&#34;llvm-的-架構&#34;&gt;LLVM 的 架構&lt;/h3&gt;

&lt;p&gt;Source code -&amp;gt; clang(lexer -&amp;gt; parser -&amp;gt; AST) -&amp;gt; LLVM IR -&amp;gt; LLVM bitcode -&amp;gt; object code(machine code) -&amp;gt; linker&lt;/p&gt;

&lt;h3 id=&#34;實際跑一次看看&#34;&gt;實際跑一次看看&lt;/h3&gt;

&lt;p&gt;而用實際上的llvm的module，達成從&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        clang            llvm-as                 lli
C code -------&amp;gt; llvm IR ---------&amp;gt; llvm bitcode -----&amp;gt; result
                          llc                 GNU ld
                llvm IR -------&amp;gt; object code --------&amp;gt; binary file
                        | llc                          GNU gcc
                        -------&amp;gt; naive assembly code ----------&amp;gt; binary file
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main() {
    int a = 2 + 5;
    int b = a + 10 + 30;
    int c = a * b + 30 + a;
    
    char s[100];
    sprintf(s, &amp;quot;%d&amp;quot;, c);
    puts(s);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;執行結果為366&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;clang利用特定指令使其在編譯過程中停止，並且生成中間產物。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clang -emit-llvm -c test.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clang -emit-Optimizerllvm -S test.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bRy0JPr.png&#34; alt=&#34;test.ll&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;front-end&#34;&gt;Front End&lt;/h2&gt;

&lt;p&gt;Clang是llvm官方的front end，主要針對C, C++和Objective-C和等語言而作。最主要負責的工作為將source code 轉換成 AST (Abstract Syntax Tree)，在將其轉換為 llvm IR。&lt;/p&gt;

&lt;p&gt;雖然說是前端，不過實際上的使用的時候可以加入多樣參數，完成編譯程式的每一個環節。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在編譯期間加入 -### 參數可以查看clang究竟調用了多少額外的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ast&#34;&gt;AST&lt;/h3&gt;

&lt;p&gt;##Optimizer&lt;/p&gt;

&lt;h3 id=&#34;ir&#34;&gt;IR&lt;/h3&gt;

&lt;h3 id=&#34;ssa&#34;&gt;SSA&lt;/h3&gt;

&lt;h2 id=&#34;back-end&#34;&gt;Back End&lt;/h2&gt;

&lt;h3 id=&#34;dag&#34;&gt;DAG&lt;/h3&gt;

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Fcitx 輸入法與新酷音</title>
      <link>https://bemg.github.io/blog/posts/fcitx-input-method/</link>
      <pubDate>Sun, 25 Feb 2018 12:04:05 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/fcitx-input-method/</guid>
      <description>

&lt;p&gt;在ubuntu底下有內建輸入法ibus，但是其使用上的體驗與在windows上的新注音輸入法有比較大的隔閡，用起來不是很習慣。在尋找更好的輸入法時，有嘗試過gcin與Rime。下面分別說說他們的缺點。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcin

&lt;ul&gt;
&lt;li&gt;這個輸入法沒有辦法自動學習正確的詞彙，以及一開始預設的字典挺小的。用起來時常會打錯字，需要細心的一一修正，用起來不是很方便。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;rime

&lt;ul&gt;
&lt;li&gt;在字典的自動修正上與新詞彙的學習上都較為良好，但是在輸入法的使用上，rime並不會限制你的輸入，也就是說就算你輸入了一連串完全沒有待選字的注音，它還是會讓你繼續輸入，很大程度上要求你字字輸入清楚，用起來壓力很大。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fcitx&#34;&gt;fcitx&lt;/h2&gt;

&lt;p&gt;於是乎我就找到了另外一款兼具gcin輸入方式與rime的詞彙精準度的輸入法 新酷音。下面簡單的介紹如何安裝與使用。&lt;/p&gt;

&lt;h3 id=&#34;安裝&#34;&gt;安裝&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install fcitx fcitx-chewing fcitx-anthy
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;fcitx 是輸入法框架&lt;/li&gt;
&lt;li&gt;chewing 是新酷音&lt;/li&gt;
&lt;li&gt;anthy 是一款日文輸入法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;設定&#34;&gt;設定&lt;/h3&gt;

&lt;p&gt;System setting -&amp;gt; language support -&amp;gt; language tab -&amp;gt; Keyboard input method system -&amp;gt; 調整為fcitx&lt;/p&gt;

&lt;p&gt;如果沒有跳出fctix，請重新登入系統。&lt;/p&gt;

&lt;p&gt;開啟 fcitx 的 configue 加入，fcitx-chewing與fcitx-anthy。&lt;/p&gt;

&lt;h3 id=&#34;操作&#34;&gt;操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl-space&lt;/code&gt; fcitx的啟用與關閉

&lt;ul&gt;
&lt;li&gt;常用於切換成英文輸入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl-shift&lt;/code&gt; 在fcitx啟動的情況下，循環切換設定的輸入法&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>閱讀列表</title>
      <link>https://bemg.github.io/blog/posts/reading-list/</link>
      <pubDate>Tue, 20 Feb 2018 13:46:39 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/reading-list/</guid>
      <description>

&lt;p&gt;紀錄一下看過的書，心有餘力會新增對於每本書的評價。&lt;/p&gt;

&lt;p&gt;多少會有暴雷的風險，如果有這方面的顧慮就別看了。&lt;/p&gt;

&lt;h2 id=&#34;歷史類&#34;&gt;歷史類&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;海都物語

&lt;ul&gt;
&lt;li&gt;描寫威尼斯共和國從建國到亡國的興亡史，很明顯的看得出作者對於威尼斯有許多個人情感存在，各種對於威尼斯來說負面的歷史事件都會勇於辯護(例：第四次十字軍東征，威尼斯用計驅使聯軍去攻打君士坦丁堡，順利扶持支持威尼斯的政權;後期，威尼斯對於鄂圖曼土耳其的壓迫，動不動就想要暗殺其領袖，真不知道作者前面描寫那麼多威尼斯因為貿易需要所以兼容並蓄是為了什麼，最後還不是要動刀動槍)，不過也在其中得到了一些從國中以來的困惑。當初國中世界史章節的封面有一張十字軍攻陷君士坦丁堡的畫，可是在於國中歷史課本之中根本沒有去解釋有著大義的十字軍為什麼需要去攻陷有著東羅馬帝國的首都。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;小說&#34;&gt;小說&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文學少女

&lt;ul&gt;
&lt;li&gt;拿許多知名的經典小說的情節去進行重新的演繹，不過在沒有看過採用的經典的讀者而言，或多或少會失去部份的樂趣。表面上是對於經典情節的重新詮釋，深處其實在於主角的心理陰影(「心葉，你一定不懂吧。」)與女主角布局到最後一集的深意，本傳前後有8本，不算少，看的到是挺輕鬆的，沒有壓力與需要重覆理解的章節。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大典

&lt;ul&gt;
&lt;li&gt;一本用近現代科技去寫的科幻小說，前面看起來鋪陳不錯，可是一到中間的轉折看起來就很勉強。先不論其過於牽強的情節，這本書想要告訴讀者的主題是，集權國家藉由科技的力量控制國家的極致後，會發生什麼事情。根據作者推想之後得出的結論是，操作科技的技術人員會成為最大的漏洞，而集權也會因為這份過強的科技輕易的覆滅。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;吃掉死神的少女

&lt;ul&gt;
&lt;li&gt;整體看來，著實過於著重在對於戰爭殘酷的描寫，用於去陪襯主角的瘋狂與已經不屬於人的心態。整體的步調顯得沉悶，我給予的評價並沒有如同網路上的評價一樣高。過度描寫的血腥場景只會造成閱讀的障礙。相較之下，對於其他配角的描寫就出色了許多，一如主角的副官在尋找一個可以用來信仰的英雄;軍官為了家族的榮光不惜動用各種狡計;走頭無路的國王對於臣子的寬容。比起主角都更加的像個人。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;盜夢偵探&lt;/li&gt;
&lt;li&gt;新本格魔法少女莉絲佳

&lt;ul&gt;
&lt;li&gt;因為作者是西尾維新，所以一開始就有預感這不會是什麼正常的魔法少女，主角群肯定都是一些人格異常的傢伙。實際看下來也實際如此。雖然主角群人格異常，可是並沒有脫離古典魔法少女的公式(事件-&amp;gt;嘗試解決-&amp;gt;失敗-&amp;gt;交給魔法少女變身作結)，可是至今這個系列只有兩本，感受不到西尾維新的誠意阿。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;黑暗的左手

&lt;ul&gt;
&lt;li&gt;科幻。虛構的星球。虛構的新人類。移除了人與人之間於性別的隔閡。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;阿特拉斯聳聳肩

&lt;ul&gt;
&lt;li&gt;這本書是遊戲 bioshock 的靈感來源，可以說是這本小說的續集，在演示如果這個所謂有能力的人所建構出來的烏托邦成真其後續的結果。原書鼓吹自由主義，右派的極致。相信個人的努力遠超過環境的影響。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;駭客與畫家

&lt;ul&gt;
&lt;li&gt;我認為過譽了。全書有將近一半的篇幅都在吹捧作者在成立公司期間的豐功偉業。另外一半在談作者所認知的世界應該是怎麼樣運作的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他非虛構&#34;&gt;其他非虛構&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;老科技的全球史&lt;/li&gt;
&lt;li&gt;娛樂至死 : 追求表象﹑歡笑和激情的電視時代&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>英文學習</title>
      <link>https://bemg.github.io/blog/posts/learn-english/</link>
      <pubDate>Tue, 20 Feb 2018 13:46:33 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/learn-english/</guid>
      <description>

&lt;p&gt;紀錄一下到目前為止對於英文學習的心得與方法。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;英文對我來說很困難，從小學就有的科目而言，長達十幾年的學習。依舊仍然停滯在沒有辦法自在運用的程度。&lt;/p&gt;

&lt;p&gt;直到近期才真正的正視英文能力的養成。故在此紀錄我從2017/07開始至今的英文學習歷程。希望可以給有相同困擾的人一個努力的方向。&lt;/p&gt;

&lt;h2 id=&#34;本文&#34;&gt;本文&lt;/h2&gt;

&lt;h3 id=&#34;目標&#34;&gt;目標&lt;/h3&gt;

&lt;p&gt;我對於學習英文的第一階段目標是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;閱讀原文文章&lt;/li&gt;
&lt;li&gt;看英文影片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是聽與讀的部份。&lt;/p&gt;

&lt;p&gt;在技術的方面，由英文所撰寫的第一手文章，其數量與正確度比起經過翻譯的第二手文章來說，都高上許多。&lt;/p&gt;

&lt;p&gt;故先以這兩項能力為目前的目標。&lt;/p&gt;

&lt;h3 id=&#34;閱讀&#34;&gt;閱讀&lt;/h3&gt;

&lt;p&gt;閱讀所使用的材料多半取自於新聞與技術文章。而在閱讀的過程中，我意識到了英文能力低落的關鍵，單字量完全不足，在一句英文句子有高達三個單字完全無法理解的情況下，要理解其想要傳達的含意簡直是癡人說夢。&lt;/p&gt;

&lt;h3 id=&#34;聽力&#34;&gt;聽力&lt;/h3&gt;

&lt;p&gt;我用來練習的影片多半來自於youtube&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCCODtTcd5M1JavPCOr_Uydg&#34;&gt;Extra Credits&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;這個頻道有很多的關於歷史與遊戲機制設計的影片。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很遺憾的是，很多時候沒有辦法聽懂內容跟單字量有相當高的相關，根本就不理解那個單字，是要怎麼可以從一連串的發音中辨識出來想要提供的含意。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;根據我一個英文很好的同學表示，裡面的單字水準真的是比較高。或許該找一下有沒有比較符合我這個英文水準的好頻道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;現階段的努力&#34;&gt;現階段的努力&lt;/h2&gt;

&lt;p&gt;總結上述的問題，充實我的英文單字量是刻不容緩的工作。&lt;/p&gt;

&lt;p&gt;起先我拿出了我塵封已久的高中7000單字書，步上了過去高中的單字學習法。重溫了高中的單字學習的過程中，我進行了幾項對於方法的修正。我不再要求可以對於英文單字每一個字母都可以熟記，雖然因為在於高中時期需要熟記拼字才可以有辦法成功的寫英文考卷。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;很快的，7000單字都已經被我輸入到anki之中了，現在就是見識它的威力的時刻。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我使用了一些輔助的被單字軟體&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;anki

&lt;ul&gt;
&lt;li&gt;免費的，可以用xml或者css客製化字卡的外觀。並且遵循著學習遺忘曲線進行單字的複習。&lt;/li&gt;
&lt;li&gt;我現在的設置為50個新單字 250 複習的單字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;更新&#34;&gt;更新&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2018/03/27

&lt;ul&gt;
&lt;li&gt;得到了一些新的想法，對於單字卡來說。正面：一個生字搭配一個例句，背面：單字的中文解釋。這樣的搭配可以有效的記憶中文解釋，而且這個搭配也是正常閱讀的時候所擁有的上下文。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>