<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BeMg</title>
    <link>https://bemg.github.io/blog/</link>
    <description>Recent content on BeMg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Sep 2018 17:57:41 +0800</lastBuildDate>
    
        <atom:link href="https://bemg.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vector Architecture Notes 3 - x86</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-3/</link>
      <pubDate>Sun, 02 Sep 2018 17:57:41 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-3/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;對於 Vector Architecture 做一下筆記。對於各種不同的 ISA 的 vector extension 進行比較。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;computer architecture a quantitative approach 課本筆記 -&amp;gt; 實際上就是 VMIPS&lt;/li&gt;
&lt;li&gt;riscv vector extension tutorial&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x86&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;MMX&lt;/li&gt;
&lt;li&gt;SSE&lt;/li&gt;
&lt;li&gt;AVX&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;arm ISA vector extension&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;x86-simd-history&#34;&gt;X86 SIMD history&lt;/h2&gt;

&lt;p&gt;這個系列指令是由 intel 所開發，順序如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;MMX -&amp;gt; SSE -&amp;gt; AVX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;皆是基於前者再進行擴充。分類上皆是 SIMD 指令集。版本一大堆。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MMX (Matrix Math Extension)&lt;/li&gt;
&lt;li&gt;SSE (Streaming SIMD Extension)

&lt;ul&gt;
&lt;li&gt;2, 3, 4, 4.1, 4.2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;AVX (Advanced Vector Extension)

&lt;ul&gt;
&lt;li&gt;2, 512&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至於彼此之間有沒有被取代的問題還需要再研究。&lt;/p&gt;

&lt;h2 id=&#34;mmx&#34;&gt;MMX&lt;/h2&gt;

&lt;p&gt;有一些資料稱呼這個指令集的全名為 Matrix Math extensions。不過這個不是很重要的問題。&lt;/p&gt;

&lt;p&gt;主要是用於加速 media 與 communications 應用。&lt;/p&gt;

&lt;h3 id=&#34;架構與暫存器&#34;&gt;架構與暫存器&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BAmVbSw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;8 個 64-bits width 的 Reigster -&amp;gt; 被稱呼為 MMX register

&lt;ul&gt;
&lt;li&gt;MM0~MM7&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/Tx9ybIZ.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;8 個 32-bits width 的 general-purpose register

&lt;ul&gt;
&lt;li&gt;因為 MMX reigster 規定不行作為 address operand。&lt;/li&gt;
&lt;li&gt;EAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;四種不相同的 data type

&lt;ul&gt;
&lt;li&gt;packed bytes (8 bits)&lt;/li&gt;
&lt;li&gt;packed word (16 bits)&lt;/li&gt;
&lt;li&gt;packed doubleword (32bits)&lt;/li&gt;
&lt;li&gt;quadword (64 bits)&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/nqrXLkP.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;執行模型&#34;&gt;執行模型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;大多數的指令的operand為 dest src1 src2

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/JhALka5.png&#34; alt=&#34;1535888169340&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;有些說 operand 有兩個，有的說有三個，似乎是因為版本不同。兩個的版本是寫 dest 可以被當作 src2，運算完成後覆蓋原本的資料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Saturation and Wraparound mode

&lt;ul&gt;
&lt;li&gt;Saturation&lt;/li&gt;
&lt;li&gt;設定數值的上限與下限，當運算值超出時鎖死在上下限。&lt;/li&gt;
&lt;li&gt;Wraparound&lt;/li&gt;
&lt;li&gt;就讓它overflow，只取需要的 low bits&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/dEsjySW.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;指令&#34;&gt;指令&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/O76Gq0Q.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;data transfer

&lt;ul&gt;
&lt;li&gt;MMX register 與 memory 之間資料傳遞&lt;/li&gt;
&lt;li&gt;只有 32bits 與 64 bits 兩種&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;arithmetic

&lt;ul&gt;
&lt;li&gt;加減乘除&lt;/li&gt;
&lt;li&gt;針對那一種 data type 那一種 saturation mode unsigned or signed 都寫在指令上了&lt;/li&gt;
&lt;li&gt;比較特殊的指令&lt;/li&gt;
&lt;li&gt;PMULHW PMULLW (multiply packed signed integers and store high result)

&lt;ul&gt;
&lt;li&gt;似乎是因為一定會爆，所以可以選說要前 16 bits 還是後 16 bits&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/hpbF4Jz.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PMADDWD (multiply and add packed integers)

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/ZK7HXlH.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;comparsion

&lt;ul&gt;
&lt;li&gt;生成一個 mask 裡面放 0 或 1&lt;/li&gt;
&lt;li&gt;怎麼放待補&lt;/li&gt;
&lt;li&gt;整個 byte/word/doubleword 放 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;或者 第一個 bits 放 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;conversion

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/5AIiXKI.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;doubleword -&amp;gt; word&lt;/li&gt;
&lt;li&gt;word -&amp;gt; byte&lt;/li&gt;
&lt;li&gt;saturated 的截斷法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;unpacking

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/LzuWYfs.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;bytes -&amp;gt; word&lt;/li&gt;
&lt;li&gt;word -&amp;gt; doubleword&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;logical

&lt;ul&gt;
&lt;li&gt;and, or, xor, andn (疑？怎麼不是 nand)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;shift&lt;/li&gt;
&lt;li&gt;Empty MMX state instruction

&lt;ul&gt;
&lt;li&gt;似乎跟 float-point FPU 的運作有關&lt;/li&gt;
&lt;li&gt;細節待補，暫時視為切換運算模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sse&#34;&gt;SSE&lt;/h2&gt;

&lt;h2 id=&#34;avx&#34;&gt;AVX&lt;/h2&gt;

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html&#34;&gt;Intel® 64 and IA-32 Architectures Software Developer’s Manual vol 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.intel.com.tw/content/www/tw/zh/architecture-and-technology/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.html&#34;&gt;Intel® 64 and IA-32 Architectures Software Developer’s Manual vol 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.intel.com.tw/content/www/tw/zh/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html&#34;&gt;Intel® 64 and IA-32 Architectures Software Developer’s Manual vol 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What Is Fixed Point</title>
      <link>https://bemg.github.io/blog/posts/what-is-fixed-point/</link>
      <pubDate>Fri, 31 Aug 2018 12:30:33 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/what-is-fixed-point/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;因為在閱讀 ISA 的文件時，對於常常出現的名詞不是十分清楚。主要將重點把在：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fixed point&lt;/li&gt;
&lt;li&gt;float point&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fixed-point&#34;&gt;Fixed Point&lt;/h2&gt;

&lt;h3 id=&#34;結構&#34;&gt;結構&lt;/h3&gt;

&lt;p&gt;fixed point 由兩個部份組合&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integer part&lt;/li&gt;
&lt;li&gt;Scaling factor part

&lt;ul&gt;
&lt;li&gt;通常用 10 或者 2 的指數形式表達&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;例如：1.23 在 fixed point 中可以被表達為，1230 與 1/1000。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;操作&#34;&gt;操作&lt;/h3&gt;

&lt;p&gt;如果要轉換從一個 scaling factor 到另外一個不相同的 scaling factor。最簡單的方法就是 fixed point 還原成真正的數值，然後再 scaling 一次。我們可以定義一下各種數值，然後用數學公式來表示這種情況。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;令 I 為原始值的 Integer part&lt;/li&gt;
&lt;li&gt;令 N 為 目標值&lt;/li&gt;
&lt;li&gt;令 R 為原始值的 scaling factor&lt;/li&gt;
&lt;li&gt;令 S 為目標值的 scaling factor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
N = I * \frac{R}{S}
$$&lt;/p&gt;

&lt;p&gt;如果 R 與 S 並非可以整除的關係的話，則必須考慮 Round 的問題。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Round 好像沒有一個統一的中文翻譯可以用，其含意在於因為各種原因沒有辦法精確的描述一個數值而採用近似的方式表達。Round 就是指從精確到近似的過程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;加減法

&lt;ul&gt;
&lt;li&gt;如果有相同的 scaling factor 則直接加減 Integer part 即可&lt;/li&gt;
&lt;li&gt;不同 scaling factor 則利用上述轉換 scaling factor 的技巧統一 scaling factor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;乘法

&lt;ul&gt;
&lt;li&gt;兩個 part 都相乘&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;除法

&lt;ul&gt;
&lt;li&gt;兩個 part 都相除&lt;/li&gt;
&lt;li&gt;很容易就會遇到 round 的問題&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;這邊實際還有一個 Saturation arithmetic 的議題，雖然我不大清楚為什麼需要這個功能，但還是在這邊簡述一下。 Saturation 就是讓數值運算時有上限與下限，使其觸碰到邊界時不會發生 overflow/underflow。就讓它卡死在邊界上。&lt;/p&gt;

&lt;h3 id=&#34;實際上的數值表達形式&#34;&gt;實際上的數值表達形式&lt;/h3&gt;

&lt;p&gt;實際上在程式中使用 fixed point，scaling factor 存在於指令之中，Integer part 則是 encoding 在 memory。&lt;/p&gt;

&lt;p&gt;其表達形式許多種，但是最泛用的形式為 &lt;code&gt;Qm.n&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;m 代表 Integer part 的 bit 數&lt;/li&gt;
&lt;li&gt;n 代表 scaling factor 的數值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;指令為 Q8.2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有八個 bits&lt;/li&gt;
&lt;li&gt;要對其 scaling (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所以對於 &lt;code&gt;0b11010100&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$
\frac{1}{2^2} * (2^2 + 2^4 + 2^6 + 2^7) = 53
$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;預設為 unsigned，signed 的就是將其 integer part 用 signed 的方式解讀。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除此之外也有 Qn 的形式，直接使用系統預設的數值表達長度(8, 16, 32 bits&amp;hellip;)，只紀錄下 scaling factor 的部份。&lt;/p&gt;

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fixed-point_arithmetic&#34;&gt;Fixed-point arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://courses.cs.washington.edu/courses/cse467/08au/labs/l5/fp.pdf&#34;&gt;Fixed-Point Arithmetic: An Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Saturation_arithmetic&#34;&gt;Saturation arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go goroutine</title>
      <link>https://bemg.github.io/blog/posts/go-waitgroup/</link>
      <pubDate>Mon, 27 Aug 2018 11:16:03 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/go-waitgroup/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;這篇文章會包含 goroutine 的一些用法與需要注意的要點。&lt;/p&gt;

&lt;p&gt;在這個問題上，我們需要釐清的重點在於&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;goroutine&lt;/li&gt;
&lt;li&gt;channel&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;waitgroup&lt;/li&gt;
&lt;li&gt;timeout&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;goroutine&lt;/code&gt;是 golang 中一個重要的 feature，概念上就是從程式語言的層次上支援 coroutine 的功能。可以在低成本(不論是硬體或者是程式撰寫的部份)的情況下大量的使用平行化。&lt;/p&gt;

&lt;p&gt;從最近使用的感想上來說，可以理解為，被指定由&lt;code&gt;goroutine&lt;/code&gt;方法執行的程式區塊，是被直接丟進另外一個&lt;code&gt;task pool&lt;/code&gt; 中等待電腦去執行它。至於 golang 是如何實現讓這些大量的 task 去榨乾所有的運算支援大概可以再寫一篇文章來討論。&lt;/p&gt;

&lt;p&gt;被放出去的執行的程式，我們可以使用 channel 作為傳遞資料的管道，也可以作為一種 wait 的方法。當有多個 coroutine 同時在背景執行時，且每個 coroutine 個別的結果需要分別處理時，就可以利用 select 去接 channel 並且分開來處理。&lt;/p&gt;

&lt;p&gt;當不需要分開處理又需要等待所有的coroutine執行完畢。就簡單的使用 sync.waitgroup 去執行與等待。&lt;/p&gt;

&lt;p&gt;在每個執行的程式之中，有些程式可能會卡死，原因很多，像是網路不通阿。要取得的東西太大&amp;hellip;總之，如果讓整個程式就卡在這裡的話，就沒有加速的意義了。所以需要一個timeout來限制最長的執行時間，如果時間到 coroutine 卻還沒有執行完成，那就進行其他的處理。&lt;/p&gt;

&lt;h2 id=&#34;範例-goroutine-and-channel&#34;&gt;範例 Goroutine and Channel&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;func main() {
    
    c1 := make(chan int)
    go func () {
        c1 &amp;lt;- do_something_computer1() 
    }()
    
    c2 := make(chan int)
    go func () {
        c2 &amp;lt;- do_something_computer2()
    }()
    
    result := &amp;lt;-c1 + &amp;lt;-c2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;調用 gooutine 的關鍵字為 &lt;code&gt;go&lt;/code&gt; 只能加在一個 method/function 調用之前(待驗證)。用途就是將這個 func 令其在丟進 task pool。&lt;/li&gt;
&lt;li&gt;channel 為goroutine之間溝通的管道，我們可以利用其來達成 wait 的效果。

&lt;ul&gt;
&lt;li&gt;channel 的宣告為在變數之前加上 chan，例：chan int&lt;/li&gt;
&lt;li&gt;channel 的使用上會用 &amp;lt;-，由變數的位置來決定是取用還是寫入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;系統會等到c1與c2都執行完成才會結束。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如果不 wait，執行過程不會等待 goroutine 執行結束與否就直接 exit&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;範例-waitgroup-select-and-timeout&#34;&gt;範例 waitgroup, select and timeout&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;func main() {
    var wg snyc.waitgroup
    for i, v := range list_of_string {
        wg.Add(1)
        go func (s string, wg *sync.waitgroup) {
            do_something(s)
            wg.Done()
        }(v, wg)
    }
    c1 = make(chan int)
    go func () {
        wg.Wait()
        close(c1)
    }()
    
    select {
    case &amp;lt;- c1:
        fmt.Printf(&amp;quot;Success.\n&amp;quot;)
    case &amp;lt;- time.After(100 * time.Second):
        fmt.Printf(&amp;quot;Timeout\n&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vector Architecture Notes SIMDandGPU</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-simdandgpu/</link>
      <pubDate>Sat, 18 Aug 2018 20:55:53 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-simdandgpu/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;對於現行的 SIMD(Single instruction multiply data) 架構進行比較，主要有以下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vector instructions&lt;/li&gt;
&lt;li&gt;SIMD instructions&lt;/li&gt;
&lt;li&gt;GPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要的內容取至 computer architecture a quantitative approach chp4.1-4&lt;/p&gt;

&lt;h2 id=&#34;vector-instructions&#34;&gt;Vector instructions&lt;/h2&gt;

&lt;p&gt;請看&lt;a href=&#34;https://bemg.github.io/blog/posts/vector-architecture-notes-1/&#34;&gt;這篇&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;simd-instructions-for-multimedia&#34;&gt;SIMD instructions for multimedia&lt;/h2&gt;

&lt;p&gt;此處的 SIMD instruction 主要是為了 Multimedia 所設計。跟現實中所謂的 SIMD 的定義有一些微妙的差異。如果直接講結論的話，應當可以是這一類 SIMD 為 vector instruction 的 subset。是為了硬體的複雜度與效能上做出的取捨。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大多數的 graphics system 會分別使用 8-bits 去表達三原色，在使用一個額外的 8-bits 表達透明度。剛好用完一個 32-bits。&lt;/p&gt;

&lt;p&gt;audio sample (聲音取樣) 通常被表達為 8-bits 或者 16-bits&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;知名的 SIMD for multimedia&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MMX&lt;/li&gt;
&lt;li&gt;SSE&lt;/li&gt;
&lt;li&gt;AVX&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;上述皆是 x86 下的產物，似乎可以額外做一篇筆記了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;指令&#34;&gt;指令&lt;/h3&gt;

&lt;p&gt;指令的部份一次都支援 256-bits 同時的運算。稍微進行一些換算可以得出。&lt;/p&gt;

&lt;p&gt;可以一次執行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;32 個 8-bits&lt;/li&gt;
&lt;li&gt;16 個 16-bits&lt;/li&gt;
&lt;li&gt;8 個 32-bits&lt;/li&gt;
&lt;li&gt;4 個 64-bits&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相較於 vector extension 動不動就是上百個來說確實小多了。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Instruction category&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Unisgned add/subtract&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Maximum/minimum&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Average&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Shift right/left&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Floating point&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;Floating point 沒有一個 element 是 8-bits。所以這部份從 16-bits 開始。細節的部份就之後在探討。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;與vector-的差異&#34;&gt;與Vector 的差異&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Register 數量更少&lt;/li&gt;
&lt;li&gt;指令運作的長度固定

&lt;ul&gt;
&lt;li&gt;所以要在多少 width 的資料上進行操作是取決於指令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;沒有 stride, gather-scatter 等 load/store method&lt;/li&gt;
&lt;li&gt;沒有 mask&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;絕大多數在 VMIPS 中可以看到用以增進效能的奇招都被移除了。這些功能的減少，會導致編譯器更難以產生出 SIMD code (這裡的SIMD應當是指標題的SIMD)。接下來就是要解釋這樣做的理由。&lt;/p&gt;

&lt;h3 id=&#34;why-simd-instruction&#34;&gt;Why SIMD instruction&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;更簡單的實作&lt;/li&gt;
&lt;li&gt;比較便宜&lt;/li&gt;
&lt;li&gt;更少額外的狀態(little extar state)

&lt;ul&gt;
&lt;li&gt;我猜是指 CSR&lt;/li&gt;
&lt;li&gt;畢竟長度都被固定了，沒有什麼好記狀態的了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector 需要大量的 memory bandwidth 支撐&lt;/li&gt;
&lt;li&gt;不會遭遇到 memory access 會產生的 page fault

&lt;ul&gt;
&lt;li&gt;我想應該就是 cache miss&lt;/li&gt;
&lt;li&gt;一次 data 的讀寫不會超過一個 page size (憑記憶的 cache 知識，待查證)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定長的特性，可以更好的制定 media standard (課本片面之詞)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/dQqf7o8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基本上就是在進行 &lt;code&gt;Y[i] = a*X[i] + Y[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.4D&lt;/code&gt; 這一個後綴是只一次對 4 個 element 進行&lt;/li&gt;
&lt;li&gt;這個舉例是用 MIPS 作為指令的基礎，所以並非實際上的指令集用法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gpu&#34;&gt;GPU&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Vector Architecture Notes 2 - RISC-V Vector extension</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-2/</link>
      <pubDate>Sun, 05 Aug 2018 22:49:37 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-2/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;對於 Vector Architecture 做一下筆記。對於各種不同的 ISA 的 vector extension 進行比較。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;computer architecture a quantitative approach 課本筆記 -&amp;gt; 實際上就是 VMIPS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;riscv vector extension tutorial&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;arm ISA vector extension&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-vector-extension&#34;&gt;RISC-V vector extension&lt;/h2&gt;

&lt;p&gt;規格還在制定中，只有一些 draft 等級的東西在，姑且暫時用這些資料作為參考。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;硬體架構&lt;/li&gt;
&lt;li&gt;指令集分類&lt;/li&gt;
&lt;li&gt;範例&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;也就是說很有可能之後通通改掉，直接白研究了 QQ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;complement-vector-extension-instruction&#34;&gt;Complement vector extension instruction&lt;/h2&gt;

&lt;p&gt;根據[2]，我們可以列出所有的指令如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;operation

&lt;ul&gt;
&lt;li&gt;用途&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;body

&lt;ul&gt;
&lt;li&gt;指令的代號&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;encoding

&lt;ul&gt;
&lt;li&gt;是否已經被編碼&lt;/li&gt;
&lt;li&gt;是某編碼是根據&lt;a href=&#34;https://i.imgur.com/mvJoaeb.png&#34;&gt;這份資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;instruction detail

&lt;ul&gt;
&lt;li&gt;各種派生指令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vector-memory-instructions&#34;&gt;Vector Memory Instructions&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Body&lt;/th&gt;
&lt;th&gt;Encoding&lt;/th&gt;
&lt;th&gt;Instructions Detail&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vector load&lt;/td&gt;
&lt;td&gt;vl&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vlb, vlbu, vlh, vlhu, vlw, vlwu, vld, vflh, vflw, vfld&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector load, strided&lt;/td&gt;
&lt;td&gt;vls&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vlsb, vlsbu, vlsh, vlshu, vlsw, vlswu, vlsd, vflsh, vflsw, vflsd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector load, indexed (gather)&lt;/td&gt;
&lt;td&gt;vlx&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vlxb, vlxbu, vlxh, vlxhu, vlxw, vlxwu, vlxd, vflxh, vflxw, vflxd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector store&lt;/td&gt;
&lt;td&gt;vs&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vsb, vsh, vsw, vsd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector store, strided&lt;/td&gt;
&lt;td&gt;vss&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vssb, vssh, vssw, vssd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector store, indexed (scatter)&lt;/td&gt;
&lt;td&gt;vsx&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vsxb, vsxh, vsxw, vsxd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector store, indexed, unorder&lt;/td&gt;
&lt;td&gt;vsxu&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vsxub, vsxuh, vsxuw, vsxud&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;vector-integer-instructions&#34;&gt;Vector Integer Instructions&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Body&lt;/th&gt;
&lt;th&gt;Encoding&lt;/th&gt;
&lt;th&gt;Instructions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;vadd&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vadd, vaddi, vaddw, vaddiw&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;subtract&lt;/td&gt;
&lt;td&gt;vsub&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;vsub, vsubw&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;multiply&lt;/td&gt;
&lt;td&gt;vmul&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vmul, vmulh, vmulhsu, vmulhu&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;widening multiply&lt;/td&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vmulwdn&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;divide&lt;/td&gt;
&lt;td&gt;vdiv&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vdiv, vdivu, vrem, vremu&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shift&lt;/td&gt;
&lt;td&gt;vs&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vsll, vslli, vsra, vsrai, vsrl, vsrli&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;logical&lt;/td&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vand, vandi, vor, vori, vxor, vxori&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;compare&lt;/td&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vseq, vslt, vsltu&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fixed point&lt;/td&gt;
&lt;td&gt;vcli&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vclipb, vclipbu, vcliph, vcliphu, vclipw, vclipwu&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;vector-floating-point-instructions&#34;&gt;Vector Floating Point Instructions&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Body&lt;/th&gt;
&lt;th&gt;Encoding&lt;/th&gt;
&lt;th&gt;Instructions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;vfadd&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfadd.h, vfadd.s, vfadd.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;substract&lt;/td&gt;
&lt;td&gt;vfsub&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfsub.h, vfsub.s, vfsub.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;multiply&lt;/td&gt;
&lt;td&gt;vfmul&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfmul.h, vfmul.s, vfmul.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;divide&lt;/td&gt;
&lt;td&gt;vfdiv&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfdiv.h, vfdiv.s, vfdiv.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sign&lt;/td&gt;
&lt;td&gt;vfsgn&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfsgn{j,jn,jx}.h, vfsgn{j,jn,jx}.s, vfsgn{j,jn,jx}.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;td&gt;vfmax&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfmax.h, vfmax.s, vfmax.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;td&gt;vfmin&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfmin.h, vfmin.s, vfmin.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;compare&lt;/td&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfeq.h, vfeq.s, vfeq.d, vltq.h, vflt.s, vflt.d, vfle.h, vfle.s, vfle.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sqrt&lt;/td&gt;
&lt;td&gt;vfsqrt&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfsqrt.h, vfsqrt.s, vfsqrt.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;vfclass&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;vfclass.h, vflcass.s, vfclass.d&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;vector-floating-point-multiply-add&#34;&gt;Vector  Floating Point Multiply Add&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;operation&lt;/th&gt;
&lt;th&gt;instructions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;vfmadd.h, vfmadd.s, vfmadd.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sub&lt;/td&gt;
&lt;td&gt;vfmsub.h, vfmsub.s, vfmsub.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;widening add&lt;/td&gt;
&lt;td&gt;vfmaddwdn.h, vfmaddwdn.s, vfmaddwdn.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;widening sub&lt;/td&gt;
&lt;td&gt;vfmsubwdn.h, vfmsubwdn.s, vfmsubwdn.d&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;vector-convert&#34;&gt;Vector Convert&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;From Integer to Float&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;To Half&lt;/td&gt;
&lt;td&gt;vfcvt.h.i, vfcvt.h.u&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Single&lt;/td&gt;
&lt;td&gt;vfcvt.s.i, vfcvt.s.u&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Double&lt;/td&gt;
&lt;td&gt;vfcvt.d.i, vfcvt.d.u&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;From Float to Vemaxw Integer&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;To Signed&lt;/td&gt;
&lt;td&gt;vfcvt.i.h, vfcvt.i.s, vfcvt.i.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Unsigned&lt;/td&gt;
&lt;td&gt;vfcvt.u.h, vfcvt.u.s, vfcvt.u.d&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;From Float to Float&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;To Half&lt;/td&gt;
&lt;td&gt;vfcvt.h.s, vfcvt.h.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Single&lt;/td&gt;
&lt;td&gt;vfcvt.s.h, vfcvt.s.d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Double&lt;/td&gt;
&lt;td&gt;vfcvt.d.h, vfcvt.d.s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;From Vemaxw Int to Narrow Int&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;To Byte&lt;/td&gt;
&lt;td&gt;vcvt.{b,bu}.i&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Half&lt;/td&gt;
&lt;td&gt;vcvt.{h,hu}.i&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;To Word&lt;/td&gt;
&lt;td&gt;vcvt.{w,wu}.i&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;vector-data-movement&#34;&gt;Vector Data Movement&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Instruction&lt;/th&gt;
&lt;th&gt;action&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;insert gpr into vector&lt;/td&gt;
&lt;td&gt;vins vd, rs1, rs2&lt;/td&gt;
&lt;td&gt;vd[rs2] = rs1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;insert fp into vector&lt;/td&gt;
&lt;td&gt;vins vd, fs1, rs2&lt;/td&gt;
&lt;td&gt;vd[rs2] = fs1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;extract velem to gpr&lt;/td&gt;
&lt;td&gt;vext rd, rs1, rs2&lt;/td&gt;
&lt;td&gt;rd = vs1[rs2]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;extract velem to fp&lt;/td&gt;
&lt;td&gt;vext fd, vs1, rs2&lt;/td&gt;
&lt;td&gt;fd = vs1[rs2]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector-vector merge&lt;/td&gt;
&lt;td&gt;vmerge vd, vs1, vs2, vm&lt;/td&gt;
&lt;td&gt;mask picks src&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector-gpr merge&lt;/td&gt;
&lt;td&gt;vmergex vd, rs1, vs2, vm&lt;/td&gt;
&lt;td&gt;mask picks src&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector-fp merge&lt;/td&gt;
&lt;td&gt;vmergef vd, fs1, vs2, vm&lt;/td&gt;
&lt;td&gt;mask picks src&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector register gather&lt;/td&gt;
&lt;td&gt;vrgather vd, vs1, vs2, vm&lt;/td&gt;
&lt;td&gt;vd[i] = vs1[vs2[i]]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Gpr splat/bcast&lt;/td&gt;
&lt;td&gt;vsplatx vd, rs1&lt;/td&gt;
&lt;td&gt;Vd[0..MAXVL] = rs1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fpr splat/bcast&lt;/td&gt;
&lt;td&gt;vsplatf vd, fs1&lt;/td&gt;
&lt;td&gt;Vd[0..MAXVL] = fs1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector slide down&lt;/td&gt;
&lt;td&gt;vslidedwn vd, vs1, rs2, vm&lt;/td&gt;
&lt;td&gt;vd[i] = vs1[rs2+i]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vector slide up&lt;/td&gt;
&lt;td&gt;vslideup vd, vs1, rs2, vm&lt;/td&gt;
&lt;td&gt;vd[rs2+i] = vs1[i]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;vector-mask-operations&#34;&gt;Vector Mask Operations&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Instruction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Find first set bit in mask&lt;/td&gt;
&lt;td&gt;Vmfirst rd, vs1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mask pop count&lt;/td&gt;
&lt;td&gt;Vmpopc rd, vs1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Count preceding mask bits&lt;/td&gt;
&lt;td&gt;Vmiota vd, vm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Flag before first&lt;/td&gt;
&lt;td&gt;Vmfbf vd, vs1, vm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Flag including first&lt;/td&gt;
&lt;td&gt;Vmfif vd, vs1, vm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;很明顯可以發現絕大多數的指令都沒有被編碼，這 proposal 也是pro個辛酸的。跟沒有講差不多，更何況還語帶保留的說很有可能會改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看看就好。&lt;/p&gt;

&lt;h2 id=&#34;register-design&#34;&gt;Register Design&lt;/h2&gt;

&lt;p&gt;暫存器在 RISC-V vector extension 中主要分為兩種。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data vector register&lt;/li&gt;
&lt;li&gt;Control and State Register (CSR)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vector-data-register&#34;&gt;Vector Data Register&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;v0-31&lt;/li&gt;
&lt;li&gt;MAXVL 由實作決定&lt;/li&gt;
&lt;li&gt;資料的型態 -&amp;gt; 就指令來看，整數跟浮點數用同一組Register (待研究)&lt;/li&gt;
&lt;li&gt;有三種存放資料的方式

&lt;ul&gt;
&lt;li&gt;調用 register 時，根據其後綴決定特性。&lt;/li&gt;
&lt;li&gt;vector：像是陣列的存放法&lt;/li&gt;
&lt;li&gt;scalar：將單一資料將 vector length 放滿&lt;/li&gt;
&lt;li&gt;martix：No Spec，還在規劃中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;csr&#34;&gt;CSR&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;vcfg (WARL-&amp;gt;Wrtie Any Values, Reads Legal Values)

&lt;ul&gt;
&lt;li&gt;vregmax (8 bits)：控制 Vector data register 的數量 (disable 與否)&lt;/li&gt;
&lt;li&gt;舉例來說，如果其值為0，則 vector unit disable&lt;/li&gt;
&lt;li&gt;其值為2，則 v0, v1 啟用&lt;/li&gt;
&lt;li&gt;所以實際上 Vector Data Register 保留了可以擴充到 256 個空間&lt;/li&gt;
&lt;li&gt;vemaxw (3 bits)：設定單一個 element 有多寬&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/AkauTw2.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;vtypeen (1 bit)：啟動 type extension (功能待補)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vxcfg

&lt;ul&gt;
&lt;li&gt;vxcm (1 bit)：fixed point clip mode&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/LIWuEIx.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;vxrm (2 bits)：fixed point rounding mode&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/F1HIfM3.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vl

&lt;ul&gt;
&lt;li&gt;設定目前有效的 vector length&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;vsetvl&lt;/code&gt; 進行設定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的 CSR，都可以藉由 &lt;code&gt;vconfig&lt;/code&gt; 進行同一設定。&lt;/p&gt;

&lt;p&gt;用法：&lt;code&gt;vconfig imm&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;vdisable 寄生在 vconfig 上面，等效於 &lt;code&gt;vconfig 0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;關於-maxvl&#34;&gt;關於 MAXVL&lt;/h2&gt;

&lt;p&gt;首先要了解，硬體的空間是固定的，可以先假設為供給 vector extension 進行運用的空間有 n byte。而 MAXVL的值是從 &lt;code&gt;vconfig&lt;/code&gt;設定完之後才能進一步確定的。&lt;/p&gt;

&lt;p&gt;能夠影響參數有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vregmax -&amp;gt; 設為x

&lt;ul&gt;
&lt;li&gt;決定 register 的數量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vemaxw  -&amp;gt; 設為y

&lt;ul&gt;
&lt;li&gt;確定 element 的長度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;則 MAXVL 的值就會是
$$
MAXVL = \frac{n}{x*y}
$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;待確認正確性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;example-add-two-vector&#34;&gt;Example: add two vector&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zfqzafa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9Y2kUY5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;mask-execution&#34;&gt;Mask execution&lt;/h2&gt;

&lt;p&gt;為了處理在迴圈之中有 IF Statement。也就是在整個 vector 中，有一些 element 是不應該被執行的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mask 存放在一般的 vector data register&lt;/li&gt;
&lt;li&gt;就當作 Boolean type 讀取，讀取 LSB (最低的那個bit)做為 Boolean 的值，其他的值就直接忽略。&lt;/li&gt;
&lt;li&gt;Mask 由 compare operation 產生。&lt;/li&gt;
&lt;li&gt;雖然沒有寫得很清楚，可是 &lt;code&gt;V1&lt;/code&gt; 似乎被預設為存放 mask 的 register。&lt;/li&gt;
&lt;li&gt;絕大多數的指令都可以接受 Mask execution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以 &lt;code&gt;vfadd.s v5, v3, v4, v0.t&lt;/code&gt;為例&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vjt331M.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tuN2BsB.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;到底是 v0 還是 v1 ???&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;細節

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/5PbWx41.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;[1] mask 都是基於 v1&lt;/li&gt;
&lt;li&gt;assembly 上我猜是為了可讀性。&lt;/li&gt;
&lt;li&gt;真正決定行為的是指令的 encoding insn[26:25] -&amp;gt; m&lt;/li&gt;
&lt;li&gt;後綴規則&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.s&lt;/code&gt; -&amp;gt; 做為 scalar 表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.f&lt;/code&gt; -&amp;gt; mask 為 0 時作為 true 看待&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.t&lt;/code&gt; -&amp;gt; mask 為 1 時作為 true 看待&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;所以每個指令都有四種不一樣的 type ??? 我看 spike 是要扛不住了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;memory-load-store&#34;&gt;Memory load/store&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;當 RISC-V 在進行 load 時，讀取的長度由指令決定 (word, half word, byte&amp;hellip;)，如果 register  element 的大小與指令讀取的大小不相符時，會導致 exception。存放亦然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Normal&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/eDW5M2M.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/6QKalNr.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stride&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以 &lt;code&gt;vlsw v5,80(x3,x9)&lt;/code&gt; 為例&lt;/li&gt;
&lt;li&gt;x3[80] 為 address 起點&lt;/li&gt;
&lt;li&gt;x9為每次取用移動的距離，單位應當為 byte&lt;/li&gt;
&lt;li&gt;stride 0 是為合法的(就每一次都在同一個位置)&lt;/li&gt;
&lt;li&gt;不對齊(unaligned)存取也是合法的&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/tGCVoY8.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/uL3DHxO.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/CGAmsPL.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Gather (indexed vector)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;以 &lt;code&gt;vflxw v5, 80(x3,v2)&lt;/code&gt; 為例&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根據 vector 中的值作為 index&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Nqbckt3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8M3LjrQ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/YmPXDm6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fixed-point-instruction-待補&#34;&gt;Fixed-point instruction (待補)&lt;/h2&gt;

&lt;p&gt;好像是當 float -&amp;gt; int 時，要進行怎麼樣的處理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接捨去&lt;/li&gt;
&lt;li&gt;四捨五入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;沒有實際範例、沒有詳細說明。&lt;/p&gt;

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/riscv/riscv-v-spec&#34;&gt;riscv-v-spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://drive.google.com/file/d/1fWyhzi5XsjrdamAPZISKH7RwRgc93Q9o/view?usp=sharing&#34;&gt;The RISC-V Vector ISA Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://drive.google.com/file/d/164QVrxV5OW4peSvhP6j1POkFOYQ4t6oT/view?usp=sharing&#34;&gt;The RISC-V Vector ISA Update&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Vector Architecture Notes 1 - VMIPS</title>
      <link>https://bemg.github.io/blog/posts/vector-architecture-notes-1/</link>
      <pubDate>Sun, 05 Aug 2018 12:07:48 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/vector-architecture-notes-1/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;對於 Vector Architecture 做一下筆記。對於各種不同的 ISA 的 vector extension 進行比較。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;computer architecture a quantitative approach 課本筆記 -&amp;gt; 實際上就是 VMIPS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;riscv vector extension tutorial&lt;/li&gt;
&lt;li&gt;arm ISA vector extension&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vmips&#34;&gt;VMIPS&lt;/h2&gt;

&lt;p&gt;VMIPS 是課本作者針對於 MIPS，增加 vector instruction 的擴增板。描述了大致上的硬體架構與各種針對於效能議題上的探討。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;硬體架構&lt;/li&gt;
&lt;li&gt;指令集分類&lt;/li&gt;
&lt;li&gt;範例&lt;/li&gt;
&lt;li&gt;術語&lt;/li&gt;
&lt;li&gt;改進&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;硬體架構&#34;&gt;硬體架構&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MqS7Hjz.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vector register

&lt;ul&gt;
&lt;li&gt;預設有 8 個 vector register&lt;/li&gt;
&lt;li&gt;每個 register 有 64 個 element，每個 element 寬度為 64 bits&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector functional units

&lt;ul&gt;
&lt;li&gt;專門對 vector register 進行加法、減法、乘法、除法、邏輯運算的元件。&lt;/li&gt;
&lt;li&gt;可以被 pipelined。

&lt;ul&gt;
&lt;li&gt;這一點後面的章節會提到。就是可以先執行在 vector register 中的第一個 element，而不用等到全部的 element 都讀入 register 才開始執行。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector load/store units

&lt;ul&gt;
&lt;li&gt;在 register 與 memory 之間讀入/寫入資料。&lt;/li&gt;
&lt;li&gt;一樣是可以被 pipelined。&lt;/li&gt;
&lt;li&gt;也支援 scalar 的 load/store&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;scalar register

&lt;ul&gt;
&lt;li&gt;就是 MIPS 中原本的那些 register。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在此還有兩個特殊的 register 留待後續討論。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VLR (vector length regist)

&lt;ul&gt;
&lt;li&gt;處理 vector 長度變化問題。&lt;/li&gt;
&lt;li&gt;strip mining&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;VM (vector mask)

&lt;ul&gt;
&lt;li&gt;處理 IF statement -&amp;gt; 有一些 element 可以不用被執行到。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;指令集分類&#34;&gt;指令集分類&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/iJma1jU.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;數值運算

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;op rd, rs1, rs2 // rd[i] = rs1[i] op rs2[i] for all i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ADD__.D&lt;/li&gt;
&lt;li&gt;SUB__.D&lt;/li&gt;
&lt;li&gt;MUL__.D&lt;/li&gt;
&lt;li&gt;DIV__.D&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;load/store

&lt;ul&gt;
&lt;li&gt;普通的從出發點取 VLR 長度的資料 &lt;code&gt;op v1, r1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;LV&lt;/li&gt;
&lt;li&gt;SV&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;跳著取，為了滿足多維矩陣的存取 (column-base or row-base)

&lt;ul&gt;
&lt;li&gt;LVWS&lt;/li&gt;
&lt;li&gt;SVWS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;對於一個 vector register 中存放特定的 index，並且根據這個 index 去取得特定 memory 位置的值。(為了滿足稀疏矩陣)

&lt;ul&gt;
&lt;li&gt;LVI&lt;/li&gt;
&lt;li&gt;SVI&lt;/li&gt;
&lt;li&gt;CVI&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;設定指令長度

&lt;ul&gt;
&lt;li&gt;MTCL&lt;/li&gt;
&lt;li&gt;MFCL&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;設定mask

&lt;ul&gt;
&lt;li&gt;生成 mask，結果會存在 VM 這個 register 裡面

&lt;ul&gt;
&lt;li&gt;S&amp;ndash;VV.D -&amp;gt; vector 對 vector&lt;/li&gt;
&lt;li&gt;S&amp;ndash;VS.D -&amp;gt; vector 對 scalar&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;存放 VM

&lt;ul&gt;
&lt;li&gt;MVTM&lt;/li&gt;
&lt;li&gt;MVFM&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;範例&#34;&gt;範例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Y[i] = a*X[i] + Y[i] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假設陣列 X 與 Y 的起點在 Rx 與 Ry&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通的指令

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/VbbIKuI.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有 vector instruction 指令

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/3zl5m5z.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;術語&#34;&gt;術語&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;chained

&lt;ul&gt;
&lt;li&gt;就是上面提到的可以被 pipeline&lt;/li&gt;
&lt;li&gt;不用等到整個vector執行完成才能執行下一步&lt;/li&gt;
&lt;li&gt;可以一個接一個 element 進行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;convey

&lt;ul&gt;
&lt;li&gt;特定的 code 區塊，用意在於計算程式執行效率&lt;/li&gt;
&lt;li&gt;根據 structual hazard 或者 data hazard 進行分隔

&lt;ul&gt;
&lt;li&gt;碰到這兩個就不能 pipeline 了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因為可以pipeline，執行時間大致可以視為 vector 長度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;chime

&lt;ul&gt;
&lt;li&gt;一個 convey 執行的時間&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;改進&#34;&gt;改進&lt;/h3&gt;

&lt;p&gt;主要就是在提昇效能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同一個 clock cycle 執行多個 element -&amp;gt; Multiple Lane&lt;/li&gt;
&lt;li&gt;程式的 array 長度並非 64 的倍數 -&amp;gt; Vector-Length Register

&lt;ul&gt;
&lt;li&gt;array 的長度有可能會到 run time 才能確定&lt;/li&gt;
&lt;li&gt;需要 VLR 的原因&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;讓有 IF 的程式也可以向量化 -&amp;gt; Vector Mask Register

&lt;ul&gt;
&lt;li&gt;需要 MASK 的原因&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加速資料讀寫 -&amp;gt; Memory Bank&lt;/li&gt;
&lt;li&gt;多維陣列支援 -&amp;gt; Stride&lt;/li&gt;
&lt;li&gt;稀疏陣列支援 -&amp;gt; Gather-Scatter&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;multiple-lane&#34;&gt;Multiple Lane&lt;/h4&gt;

&lt;p&gt;在一個 clock cycle 執行多個操作，以增進效能。實際上解決方法是相當簡單粗暴的。大致上有兩種方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多個 function unit

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/Jn9Pgt8.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多個 lane

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/kaJDKdV.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;似乎可以兩種一起使用，待研究&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;vector-length-register&#34;&gt;Vector-Length Register&lt;/h4&gt;

&lt;p&gt;實際上在寫程式的時候，很難會有需要向量化的區域數量剛好與 register 的最大長度相符合(剛好成倍數)。而且這個長度有可能會到執行階段才能決定。下面這個程式就是一個例子 &lt;code&gt;n&lt;/code&gt; 到執行階段才能確定他的值為何。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(int i=0; i&amp;lt;n; i++) {
    // Do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以對於 vector 來說，需要一個可以動態調整 vector length 的指令以符合這個需求。在這裡便引入了一個特殊的 register，叫做 VLR (Vector length register)，並且維護另外一個值為 MVL (max vector length)。&lt;/p&gt;

&lt;p&gt;如此一來在面對，與 vector 長度不成倍數的問題時，就可以根據 VLR 的設定進行處理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mchlpsb.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/uSgjsve.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;vector-mask-register&#34;&gt;Vector Mask Register&lt;/h4&gt;

&lt;p&gt;在需要向量化的區域中，有時候會包含 IF Statement，也就是說會根據 IF 內容的不同，在一長串的 vector 中，有一些 element 是不會被執行到的。如果要一一按照需求執行，就沒有辦法好好的運用向量化所帶來的優勢。&lt;/p&gt;

&lt;p&gt;但是只要將這個 IF 一次執行完畢，將結果暫存起來，在執行時按照此結果運作即可。在這裡 Vector Mask Register 就是那個存結果的地方。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (i=0; i &amp;lt; 64; i++) {
    if ( X[i] != 0 ) {
        X[i] = X[i] - Y[i]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LmGfTpB.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memory-bank&#34;&gt;Memory Bank&lt;/h4&gt;

&lt;p&gt;用多個 Memory Bank 衝高 vector Load/Store Unit 的 Bandwidth。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;待補&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;stride&#34;&gt;Stride&lt;/h4&gt;

&lt;p&gt;在多維陣列中，許多時候使用的值並非都是在 memory 的下一格。而是遙遠的某一格。詳看下面範例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (int i=0; i&amp;lt;10; i++) {
    Z[i] = X[0][i] + Y[i][0];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;是 X 還是 Y 要去遙遠的地方尋找值是基於你的 memory layout 是 row-base 還是 column-base&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;專門為這個問題設定一個指令，使得程式可以跳著讀取/儲存。&lt;/p&gt;

&lt;h4 id=&#34;gather-scatter&#34;&gt;Gather-Scatter&lt;/h4&gt;

&lt;p&gt;遇到稀疏陣列時的解決方案。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (i=0; i&amp;lt;n; i++) {
    A[K[i]] = A[K[i]] + C[M[i]]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UJs4udH.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Computer Architecture A Quantitative Approach Chp4&lt;/li&gt;
&lt;li&gt;Computer Architecture A Quantitative Approach Appendix G&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Spike</title>
      <link>https://bemg.github.io/blog/posts/introduction-to-spike/</link>
      <pubDate>Wed, 01 Aug 2018 10:32:07 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/introduction-to-spike/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近花了大概兩個禮拜研究了 RISCV 的官方模擬器 (riscv-isa-sim) Spike。&lt;/p&gt;

&lt;p&gt;內容包含&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;li&gt;如何加入新的指令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安裝&#34;&gt;安裝&lt;/h2&gt;

&lt;p&gt;在使用 spike 之前，需要安裝 riscv-tools，所需要的工具大致如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;riscv-gnu-toolchain: RISC-V cross-compiler&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;riscv-fesvr: a &amp;ldquo;front-end&amp;rdquo; server that services calls between the host and target processors on the Host-Target InterFace&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;riscv-isa-sim: ISA simulator, as kown as spike&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;riscv-opcodes: the enumeration of all RISC-V opcodes executable by the simulator&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;riscv-pk: a proxy kernel that services system calls generated by code built and linked with the RISC-V Newlib port&lt;/li&gt;
&lt;li&gt;riscv-tests: a set of assembly tests and benchmarks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;粗體的部份是使用 spike 會需要理解的部份。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/riscv/riscv-tools.git
cd riscv-tools
git submodule update --init --recursive
export RISCV=/path/to/install/riscv/toolchain
./build.sh
export $RISCV/bin to $PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;覺得編譯速度不夠快可以去修改 build.sh 使用多核心&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;如何使用-spike&#34;&gt;如何使用 spike&lt;/h2&gt;

&lt;p&gt;寫程式 -&amp;gt; 用 cross-over compiler 編譯出 riscv machine code -&amp;gt; 使用 spike 運行此執行檔&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寫程式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
    int a = 1*2*3*4;
    printf(&amp;quot;%d\n&amp;quot;, a);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用cross-over compiler 編譯&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;riscv64-unknown-elf-gcc main.c -o main
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用 spike 運行此程式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;spike pk main
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;如何加入新的指令&#34;&gt;如何加入新的指令&lt;/h2&gt;

&lt;p&gt;spike 是一個 riscv 的模擬器，最主要的目標就是在沒有支援 riscv ISA 的處理器上，也可以執行以 riscv machine code 為主的程式。方便程式開發與測試。其本身就是在定義一個符合 riscv 規格的處理器。有 register 有 memory 最大程度的重現真實CPU的行為。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;當然，結果正確無誤比起流程正確無誤重要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;定義指令編碼與生成mask&lt;/li&gt;
&lt;li&gt;描述指令行為&lt;/li&gt;
&lt;li&gt;註冊進spike&lt;/li&gt;
&lt;li&gt;測試新的指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;這一個章節會以 &lt;code&gt;vfadd.s&lt;/code&gt; 作為範例&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;格式

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vfadd.s rd rs1 rs2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;讀取 rs1 與 rs2 的值，並且將加在一起的結果存在 rd。&lt;/li&gt;
&lt;li&gt;操作皆為浮點數&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;定義指令編碼與生成mask&#34;&gt;定義指令編碼與生成mask&lt;/h3&gt;

&lt;p&gt;首先必須定義好專屬於這個指令的編碼，這樣才可以在 spike 辨識出這個指令並且執行特定的行為。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;vfadd.s rd rs1 rs2 31..25=0 14..12=6 6..2=0x02 1..0=3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述編碼會將其定義在 &lt;code&gt;riscv-tools/riscv-opcodes/opcodes&lt;/code&gt;，這個檔案中存放有所有 spike 可以識別指令的編碼。理論上是不能有重覆的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;實際上有可能會出現某些指令寄生在其他指令身上的情況發生。舉例來說：&lt;code&gt;nop&lt;/code&gt;就寄生在&lt;code&gt;addi&lt;/code&gt;上。詳情可以查看規格書&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接著使用 &lt;code&gt;parse-opcode&lt;/code&gt; 這一個執行檔產生出相對應所撰寫編碼的十六進位表示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;cat opcodes opcodes-rvc-pseudo opcodes-rvc opcodes-custom | ./parse-opcodes -c | grep &amp;quot;VFADD_S&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Gl3QMq2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;這邊是一個取巧的辦法，指印出所需要新增的那一個指令。當然你可以不使用 &lt;code&gt;grep&lt;/code&gt; 直接輸出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;將這個結果加入至 &lt;code&gt;riscv-tools/riscv-isa-sim/riscv/encoding.h&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&#34;描述指令行為&#34;&gt;描述指令行為&lt;/h3&gt;

&lt;p&gt;所有行為的描述都建立在 &lt;code&gt;rsicv-tools/riscv-isa-sim/riscv/insn/[instruction name].h&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;實際上用於描述指令行為的語言是 c++，只不過 spike 用上了一堆 marco 讓它看起來很不像，這些 marco 主要是在替換調與 register 和 memory 互動的複雜性。多看幾次應該就可以感覺的出來這些 marco 實際上的行為。&lt;/p&gt;

&lt;p&gt;一樣用 vfadd.s 作為例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;vreg_t rst;
vreg_t rs1 = VRS1;
vreg_t rs2 = VRS2;
int vl = STATE.vl;

for(int i=0; i&amp;lt;vl; i++) {
    rst.f_data[i] = rs1.f_data[i] + rs2.f_data[i];
}
for(int i=vl; i&amp;lt;MAXVL; i++) {
    rst.f_data[i] = 0;
}

WRITE_VRD(rst);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;註冊指令至spike&#34;&gt;註冊指令至spike&lt;/h3&gt;

&lt;p&gt;到 &lt;code&gt;riscv-tools/riscv-isa-sim/riscv/riscv.mk.in&lt;/code&gt; 中，在&lt;code&gt;riscv_insn_list&lt;/code&gt;下加入新的指令名稱。並且重新編譯一次 spike。&lt;/p&gt;

&lt;h3 id=&#34;測試新指令&#34;&gt;測試新指令&lt;/h3&gt;

&lt;p&gt;因為並沒有實際去修改編譯器，所以編譯程式的時候，編譯並不會自動生成剛剛新增的指令。而為了加入一個新的指令而重新編譯一次編譯器太花時間了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一次大概 30 分鐘。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以在這裡使用一個小技倆，可以繞過編譯器，直接加入新的指令至執行檔。這個技倆就是 &lt;code&gt;assembly inline&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;asm __volatile__ (&amp;quot;.word [instruction encoding]\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這一個部份的關鍵就是要如何生成出正確的指令格式。關鍵如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;編碼&lt;/li&gt;
&lt;li&gt;暫存器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;這部份過於繁雜，在此不具體描述，僅提供一些想法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先定義好所需要的變數，如此編譯器就會將這些變數分配給特定的暫存器&lt;/li&gt;
&lt;li&gt;使用工具查看編譯器所產生的 &lt;code&gt;assembly&lt;/code&gt; 看這些變數&lt;/li&gt;
&lt;li&gt;自己轉換編碼，&lt;code&gt;bin to hex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新編譯一次程式&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go Notes</title>
      <link>https://bemg.github.io/blog/posts/golang-notes/</link>
      <pubDate>Tue, 31 Jul 2018 20:38:40 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/golang-notes/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;簡單的紀錄一下 golang&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基本語法&lt;/li&gt;
&lt;li&gt;爬蟲相關&lt;/li&gt;
&lt;li&gt;使用心得&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本語法&#34;&gt;基本語法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 註解的形式與c相同，雙重單斜線為單行註解。
/* 
此為多行註解
*/

// 使用外部函式庫
// 備註：沒有用到卻宣告會導致錯誤。
import (
    &amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
)

// 變數宣告
// 一樣，沒有使用卻宣告會導致錯誤。
var a [type] = value
a := value // 最常用
var a = value

// 據說會自行推理型態。

// 陣列宣告
var a [5]int;

// 切片(slice)宣告
var a []int = {1, 2 ,3, 4};
a = append(a, 5);
a[1:2] // get [2];


// 就是 c 的 printf
// golang 習慣函數的頭一個字母為大寫，似乎是隱藏了一些慣例，只要是首字大寫變為 public method 或者 variable。
//                                                ^ 待確認
fmt.Printf(&amp;quot;Hello world\n&amp;quot;)

yee := 87
fmt.Printf(&amp;quot;Yee : %d\n&amp;quot;, yee)

if [condition] {
    // condition is true then do something
} else {
    // condition is false then do something
}

for i:=0; i&amp;lt;10; i++ {
    // from 0 to 9
}

// 也有方便好用的迭代
for i, v := range [something can be iterated] {
    // in case int array
    // i will be index, v will be value
}

// _ 是一個特殊的變數，代表直接拋棄，大概就跟/dev/null差不多。
_ = 5

func func_name(input1 int, input2 string) (output1 int) {

// function body

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用-net-http-package&#34;&gt;使用 net/http package&lt;/h2&gt;

&lt;p&gt;簡單介紹一下如何使用 golang 取得網頁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// hendle err 真的很麻煩
resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;)
if err != nil {
	// handle error
}

// 等到不需要的時候就使用 後面那個指令
// 有點像是destructor
defer resp.Body.Close()

// body 為 html 本文
body, err := ioutil.ReadAll(resp.Body)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;簡單-goroutine-使用&#34;&gt;簡單 goroutine 使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
var flag int;

func do_something() {}

func foo(a []int) {
    for i, v := range a {
        go do_something(v)
    }
    flag &amp;lt;- 0  // Use channel send the signel.
}

func main() {
    a := []int{1, 2, 3, 4, 5}
    foo(a)
    &amp;lt;- flag // wait goroutine down.
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Cmder Notes</title>
      <link>https://bemg.github.io/blog/posts/cmder-notes/</link>
      <pubDate>Fri, 06 Jul 2018 13:04:56 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/cmder-notes/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在 windows 系統底下，cmd(命令提示字元)是類似於 unix bash 的功能。可是 cmd 看起來實在是不太友善，無論是用法與字體，他的指令用法也是與 unix 有很大的差異。所以在於 windows 系統下，我通常會使用有 gui 的應用程式進行操作(例：git&amp;hellip;)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一點差異：顯示當其目錄的檔案 ls vs dir&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不過大概在 2016 開始，微軟讓 windwos 10 可以支援 linux 的子系統，被稱為 &lt;code&gt;bash on windows&lt;/code&gt;，裝起來就很像一個只有 bash 的虛擬機器。&lt;/p&gt;

&lt;p&gt;cmder 就是在 cmd 上面在套一層看起來很漂亮的畫面。在搭配上 &lt;code&gt;bash on windows&lt;/code&gt;。期許可以用起來感覺像是真的在 linux 下指令。&lt;/p&gt;

&lt;h2 id=&#34;安裝&#34;&gt;安裝&lt;/h2&gt;

&lt;h3 id=&#34;bash-on-windows&#34;&gt;bash on windows&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;開啟 控制台-開啟或關閉windows功能-適用於windows的linux子系統&lt;/li&gt;
&lt;li&gt;下載 windows store 中的 ubuntu&lt;/li&gt;
&lt;li&gt;啟動cmd&lt;/li&gt;
&lt;li&gt;輸入bash -&amp;gt; 初次使用要進行安裝&lt;/li&gt;
&lt;li&gt;此後只要輸入 bash 就可以啟動&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cmder&#34;&gt;cmder&lt;/h3&gt;

&lt;p&gt;cmder 不用安裝，它就是一個資料夾，可以用dropbox還是google driver進行多台電腦同步。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去&lt;a href=&#34;http://cmder.net/&#34;&gt;官網&lt;/a&gt;下載&lt;/li&gt;
&lt;li&gt;啟動 /bin/cmder.exe&lt;/li&gt;
&lt;li&gt;啟動cmder就是啟動cmd -&amp;gt; 所以要打入bash進入 &lt;code&gt;bash on windows&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Selenium notes</title>
      <link>https://bemg.github.io/blog/posts/selenium-intro/</link>
      <pubDate>Sat, 07 Apr 2018 16:22:57 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/selenium-intro/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;對於使用javascript動態產生的網頁來說，單純的抓取html會缺失許多資訊。我們可以透過selenium執行javascript，生成我們所需要的資訊。&lt;/p&gt;

&lt;p&gt;selenium原本是被設計來進行自動化測試的，但是我們只需要它執行javascript的功能。&lt;/p&gt;

&lt;h2 id=&#34;安裝&#34;&gt;安裝&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install selenium
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此使用chrome作為範例。&lt;/p&gt;

&lt;p&gt;到&lt;a href=&#34;https://sites.google.com/a/chromium.org/chromedriver/getting-started&#34;&gt;官網&lt;/a&gt;下載chromedrive。並且將其加入至PATH中，或者在使用時指定其位置。&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from selenium import webdriver
from selenium.webdriver.chrome.options import Options

# 加入參數
chrome_options = Options()
chrome_options.add_argument(&amp;quot;--headless&amp;quot;)

# 啟動
drive = webdriver.Chrome(chrome_options=chrome_options)

# 讀取網頁
drive.get(url)

# 取得source
drive.page_source


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Elasticsearch 筆記</title>
      <link>https://bemg.github.io/blog/posts/elastic-notes/</link>
      <pubDate>Wed, 28 Feb 2018 13:22:58 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/elastic-notes/</guid>
      <description>

&lt;h1 id=&#34;elasticsearch&#34;&gt;elasticsearch&lt;/h1&gt;

&lt;h2 id=&#34;簡介&#34;&gt;簡介&lt;/h2&gt;

&lt;p&gt;基於java，所以要先裝&lt;code&gt;java &amp;gt;= 8&lt;/code&gt;。跑起來之後長的很像一台server，並且透過REST API進行資料的增減與搜尋的&lt;code&gt;query&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;傳送給elastic的資料格式以&lt;code&gt;JSON&lt;/code&gt;為主。&lt;/p&gt;

&lt;p&gt;elastic search 運作起來很像是database 下面簡單列出與database之間的對應關係。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node &amp;lt;-&amp;gt; DB server&lt;/li&gt;
&lt;li&gt;Index &amp;lt;-&amp;gt; database&lt;/li&gt;
&lt;li&gt;Type &amp;lt;-&amp;gt; Table&lt;/li&gt;
&lt;li&gt;document &amp;lt;-&amp;gt; row&lt;/li&gt;
&lt;li&gt;Field &amp;lt;-&amp;gt; column&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;不經修改，預設&lt;code&gt;elasticsearch&lt;/code&gt;會使用&lt;code&gt;localhost:9200&lt;/code&gt;作為他的接口。所以可以藉由這個路徑進行操作。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;官方推薦在&lt;code&gt;terminal&lt;/code&gt;使用&lt;code&gt;curl&lt;/code&gt;進行操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;查看目前有的&lt;code&gt;index&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;GET /_cat/indices?v
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   hw1   l8nmMoxjSYypWv0LZ0IWpA   5   1     530278            0      1.2gb          1.2gb
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;建立一個index&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;mapping = &#39;&#39;&#39;
{
    &amp;quot;settings&amp;quot; : {
        &amp;quot;number_of_shards&amp;quot; : 1
    },
    &amp;quot;mappings&amp;quot; : {
        &amp;quot;news&amp;quot; : {
            &amp;quot;properties&amp;quot; : {
                &amp;quot;body&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;text&amp;quot; },
                &amp;quot;image_link&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;},
                &amp;quot;keyword&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}, 
                &amp;quot;post_time&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;},
                &amp;quot;title&amp;quot; : {&amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;},
                &amp;quot;url&amp;quot; : {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;}
            }
        }
    }
}
&#39;&#39;&#39;
es = Elasticsearch(timeout=30, max_retries=10, retry_on_timeout=True)
es.indices.create(index=&#39;hw2&#39;, ignore=400, body=mapping)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;重點在於制定特定的mapping，如果都交給elastic自己管理的話，極有可能會發生錯誤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;加入一筆index&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;curl -XPOST &#39;locjson&#39;t:9200/test/news&#39; -d &amp;quot;{ \&amp;quot;title\&amp;quot;: \&amp;quot;yee\&amp;quot;, \&amp;quot;body\&amp;quot;: 1234 }&amp;quot; -H &#39;Content-Type: application/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;_index&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;_type&amp;quot;:&amp;quot;news&amp;quot;,&amp;quot;_id&amp;quot;:&amp;quot;LCmeGWIBVfCh6W9Xihub&amp;quot;,&amp;quot;_version&amp;quot;:1,&amp;quot;result&amp;quot;:&amp;quot;created&amp;quot;,&amp;quot;_shards&amp;quot;:{&amp;quot;total&amp;quot;:2,&amp;quot;successful&amp;quot;:1,&amp;quot;failed&amp;quot;:0},&amp;quot;_seq_no&amp;quot;:0,&amp;quot;_primary_term&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;如果不填入id的話，它會自動給一個隨機的id&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;移除整個index&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;DELETE /index_name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -XDELETE localhost:9200/[indexname]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;執行多筆指令(bulk)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;curl -XPOST &#39;localhost:9200/_bulk&#39; -d {query}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;一次只加入一筆資料速度挺慢的，初步推測是因為頻繁進行硬碟I/O的緣故，故一次新增多筆index。有效的解決這個問題。&lt;/p&gt;

&lt;p&gt;請小心，bulk不會因為單一筆query錯誤而傳出錯誤訊息，建議先使用小資料進行測試。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;elasticsearch-py&#34;&gt;elasticsearch-py&lt;/h2&gt;

&lt;p&gt;網路上有人將上訴的&lt;code&gt;REST API&lt;/code&gt;，包裝成python的&lt;code&gt;module&lt;/code&gt;。所以可以藉由此套件對elastic進行操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from elasticsearch import Elasticsearch
es = Elasticsearch()

# 我只有使用到兩個指令 bulk, search

es.bulk(body=action)
es.search(index=&#39;hw1&#39;, body={
     &amp;quot;query&amp;quot;: {

     &amp;quot;multi_match&amp;quot;: {

     &amp;quot;query&amp;quot; : keyword,

     &amp;quot;fields&amp;quot; : \[&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;\]
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json-操作&#34;&gt;JSON 操作&lt;/h2&gt;

&lt;p&gt;由於elasticsearch多使用JSON傳遞資料，在此紀錄一下一些常用的操作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寫入JSON到檔案&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(filename, &amp;quot;w&amp;quot;) as f:
    json.dump(data, f, ensure_ascii=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;ensure_ascii -&amp;gt; 設定為False，中文字才會顯示正常，不然會變成一串不是給人看的英文與數字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;讀取JSON從檔案&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(filename, &amp;quot;r&amp;quot;) as f:
    data = json.load(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;從object生成JSON&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;j = json.dumps(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;從JSON字串生成object&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = json.loads(j)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;從原始資料到前端&#34;&gt;從原始資料到前端&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;從原始資料到JSON檔&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import json
import glob

filename = glob.glob(&amp;quot;ettoday*.rec&amp;quot;)

data = \[\]
for fn in filename:
    cnt = 0
    with open(fn, &amp;quot;r&amp;quot;) as f:
        while True:
            cnt += 1
            pos = f.tell()
            useless = f.readline()
            url = f.readline()
            url = url\[3:\]
            url = url.strip(&#39;\\n&#39;)
            title = f.readline()
            title = title\[3:\]
            title = title.strip(&#39;\\n&#39;)
            useless = f.readline()
            maintext = f.readline()
            maintext = maintext.strip()
            after_pos = f.tell()
            print(&amp;quot;{}: {}&amp;quot;.format(fn, cnt))
            \# print(&amp;quot;{}:{}:{}&amp;quot;.format(url, title, maintext))
            if pos == after_pos:
                break
            else:
                data.append({
                    &#39;url&#39;:url, 
                    &#39;title&#39;:title, 
                    &#39;body&#39;:maintext})

with open(&#39;news.json&#39;, &amp;quot;w&amp;quot;) as f:
    json.dump(data, f, ensure_ascii=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;從json讀取進elastic&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from elasticsearch import Elasticsearch
import json

with open(&#39;./news_data/news.json&#39;) as f:
    Data = json.load(f)

es = Elasticsearch()
    
action = &#39;&#39;
cnt = 0
for data in Data:
    query = &#39;{&amp;quot;index&amp;quot;: {&amp;quot;\_index&amp;quot;: &amp;quot;hw1&amp;quot;, &amp;quot;\_type&amp;quot;: &amp;quot;news&amp;quot;}}\\n&#39; + json.dumps(data, ensure_ascii=False)
    action += query + &#39;\\n&#39;
    cnt += 1
    print(cnt)
    if cnt % 1000 == 0:
        es.bulk(body=action)
        action = &#39;&#39;

es.bulk(body=action)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;對elastic執行query&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def query(keyword): 
    es = Elasticsearch() 
    tmp = es.search(index=&#39;hw1&#39;, body={ &amp;quot;query&amp;quot;: { &amp;quot;multi_match&amp;quot;: { &amp;quot;query&amp;quot; : keyword, &amp;quot;fields&amp;quot; : [&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;] } } }) 
    tmp = tmp[&#39;hits&#39;][&#39;hits&#39;] 
    res = [] 
    for i in tmp: 
        res.append(i[&#39;_source&#39;]) 
    return res
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LLVM 筆記 (更新中)</title>
      <link>https://bemg.github.io/blog/posts/llvm-notes/</link>
      <pubDate>Mon, 26 Feb 2018 19:03:58 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/llvm-notes/</guid>
      <description>

&lt;h2 id=&#34;目錄&#34;&gt;目錄&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;架構&lt;/li&gt;
&lt;li&gt;實驗&lt;/li&gt;
&lt;li&gt;參考資料&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;LLVM是一個完整的編譯器基礎建設(compiler infrastructure)，與&lt;code&gt;GNU GCC&lt;/code&gt;相比，最大的差異在於大量的將compile的過程高度模組化，可以進行任意的抽換。從 source code 到 machine code，每一個階段都有相對應的module。&lt;/p&gt;

&lt;p&gt;本篇文章雖然以LLVM 為標題，可是實際上多半都在整理編譯器的相關知識，畢竟LLVM大部分都是在實做這些編譯器的技術。&lt;/p&gt;

&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Ubuntu 16.04&lt;/li&gt;
&lt;li&gt;LLVM: 7.0&lt;/li&gt;
&lt;li&gt;Clang: 7.0&lt;/li&gt;
&lt;li&gt;GCC: 5.4&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安裝&#34;&gt;安裝&lt;/h2&gt;

&lt;p&gt;從原始碼開始從頭編譯&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get update
apt-get install -y sudo subversion python-dev g++ cmake
svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
cd ../..
cd llvm/tools/clang/tools
svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra
cd ../../../..
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/lld/trunk lld
cd ../..
cd llvm
mkdir build
cd build
cmake -G &amp;quot;Unix Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release ..
make
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;架構&#34;&gt;架構&lt;/h2&gt;

&lt;h3 id=&#34;compiler-架構&#34;&gt;compiler 架構&lt;/h3&gt;

&lt;p&gt;在常見的compiler中，常見這類三段式的設計。
&lt;img src=&#34;https://i.imgur.com/miah8lO.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FrontEnd

&lt;ul&gt;
&lt;li&gt;將Source code 轉換為 IR or AST&lt;/li&gt;
&lt;li&gt;包含lexer、parser&lt;/li&gt;
&lt;li&gt;lexer： Regular Expression&lt;/li&gt;
&lt;li&gt;parser：Context-free grammar -&amp;gt; ANTLR 之類的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimizer

&lt;ul&gt;
&lt;li&gt;針對於IR進行最佳化，以追求更快的效能或者節省資源。&lt;/li&gt;
&lt;li&gt;在有中間語言的情況下，不需要針對每一種target language撰寫優化。&lt;/li&gt;
&lt;li&gt;也不需要撰寫多種不同的語言轉換。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BackEnd

&lt;ul&gt;
&lt;li&gt;將IR 轉換為 target language&lt;/li&gt;
&lt;li&gt;instruction selection&lt;/li&gt;
&lt;li&gt;register allocation&lt;/li&gt;
&lt;li&gt;instruction scheduling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而 LLVM 也是按照這三個階段的 compiler 設計為基準開發而成。&lt;/p&gt;

&lt;h3 id=&#34;llvm-的-架構&#34;&gt;LLVM 的 架構&lt;/h3&gt;

&lt;p&gt;Source code -&amp;gt; clang(lexer -&amp;gt; parser -&amp;gt; AST) -&amp;gt; LLVM IR -&amp;gt; LLVM bitcode -&amp;gt; object code(machine code) -&amp;gt; linker&lt;/p&gt;

&lt;h3 id=&#34;實際跑一次看看&#34;&gt;實際跑一次看看&lt;/h3&gt;

&lt;p&gt;而用實際上的llvm的module，達成從&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        clang            llvm-as                 lli
C code -------&amp;gt; llvm IR ---------&amp;gt; llvm bitcode -----&amp;gt; result
                          llc                 GNU ld
                llvm IR -------&amp;gt; object code --------&amp;gt; binary file
                        | llc                          GNU gcc
                        -------&amp;gt; naive assembly code ----------&amp;gt; binary file
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main() {
    int a = 2 + 5;
    int b = a + 10 + 30;
    int c = a * b + 30 + a;
    
    char s[100];
    sprintf(s, &amp;quot;%d&amp;quot;, c);
    puts(s);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;執行結果為366&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;clang利用特定指令使其在編譯過程中停止，並且生成中間產物。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clang -emit-llvm -c test.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clang -emit-Optimizerllvm -S test.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bRy0JPr.png&#34; alt=&#34;test.ll&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;front-end&#34;&gt;Front End&lt;/h2&gt;

&lt;p&gt;Clang是llvm官方的front end，主要針對C, C++和Objective-C和等語言而作。最主要負責的工作為將source code 轉換成 AST (Abstract Syntax Tree)，在將其轉換為 llvm IR。&lt;/p&gt;

&lt;p&gt;雖然說是前端，不過實際上的使用的時候可以加入多樣參數，完成編譯程式的每一個環節。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在編譯期間加入 -### 參數可以查看clang究竟調用了多少額外的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ast&#34;&gt;AST&lt;/h3&gt;

&lt;h2 id=&#34;optimizer&#34;&gt;Optimizer&lt;/h2&gt;

&lt;h3 id=&#34;ir&#34;&gt;IR&lt;/h3&gt;

&lt;h3 id=&#34;ssa&#34;&gt;SSA&lt;/h3&gt;

&lt;h2 id=&#34;back-end&#34;&gt;Back End&lt;/h2&gt;

&lt;h3 id=&#34;dag&#34;&gt;DAG&lt;/h3&gt;

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://llvm.org/docs/GettingStarted.html&#34;&gt;Getting Started with the LLVM System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aosabook.org/en/llvm.html&#34;&gt;The Architecture of Open Source Applications: LLVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fcitx 輸入法與新酷音</title>
      <link>https://bemg.github.io/blog/posts/fcitx-input-method/</link>
      <pubDate>Sun, 25 Feb 2018 12:04:05 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/fcitx-input-method/</guid>
      <description>

&lt;p&gt;在ubuntu底下有內建輸入法ibus，但是其使用上的體驗與在windows上的新注音輸入法有比較大的隔閡，用起來不是很習慣。在尋找更好的輸入法時，有嘗試過gcin與Rime。下面分別說說他們的缺點。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcin

&lt;ul&gt;
&lt;li&gt;這個輸入法沒有辦法自動學習正確的詞彙，以及一開始預設的字典挺小的。用起來時常會打錯字，需要細心的一一修正，用起來不是很方便。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;rime

&lt;ul&gt;
&lt;li&gt;在字典的自動修正上與新詞彙的學習上都較為良好，但是在輸入法的使用上，rime並不會限制你的輸入，也就是說就算你輸入了一連串完全沒有待選字的注音，它還是會讓你繼續輸入，很大程度上要求你字字輸入清楚，用起來壓力很大。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fcitx&#34;&gt;fcitx&lt;/h2&gt;

&lt;p&gt;於是乎我就找到了另外一款兼具gcin輸入方式與rime的詞彙精準度的輸入法 新酷音。下面簡單的介紹如何安裝與使用。&lt;/p&gt;

&lt;h3 id=&#34;安裝&#34;&gt;安裝&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install fcitx fcitx-chewing fcitx-anthy
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;fcitx 是輸入法框架&lt;/li&gt;
&lt;li&gt;chewing 是新酷音&lt;/li&gt;
&lt;li&gt;anthy 是一款日文輸入法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;設定&#34;&gt;設定&lt;/h3&gt;

&lt;p&gt;System setting -&amp;gt; language support -&amp;gt; language tab -&amp;gt; Keyboard input method system -&amp;gt; 調整為fcitx&lt;/p&gt;

&lt;p&gt;如果沒有跳出fctix，請重新登入系統。&lt;/p&gt;

&lt;p&gt;開啟 fcitx 的 configue 加入，fcitx-chewing與fcitx-anthy。&lt;/p&gt;

&lt;h3 id=&#34;操作&#34;&gt;操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl-space&lt;/code&gt; fcitx的啟用與關閉

&lt;ul&gt;
&lt;li&gt;常用於切換成英文輸入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl-shift&lt;/code&gt; 在fcitx啟動的情況下，循環切換設定的輸入法&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>閱讀列表</title>
      <link>https://bemg.github.io/blog/posts/reading-list/</link>
      <pubDate>Tue, 20 Feb 2018 13:46:39 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/reading-list/</guid>
      <description>

&lt;p&gt;紀錄一下看過的書，心有餘力會新增對於每本書的評價。&lt;/p&gt;

&lt;p&gt;多少會有暴雷的風險，如果有這方面的顧慮就別看了。&lt;/p&gt;

&lt;h2 id=&#34;歷史類&#34;&gt;歷史類&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;海都物語

&lt;ul&gt;
&lt;li&gt;描寫威尼斯共和國從建國到亡國的興亡史，很明顯的看得出作者對於威尼斯有許多個人情感存在，各種對於威尼斯來說負面的歷史事件都會勇於辯護(例：第四次十字軍東征，威尼斯用計驅使聯軍去攻打君士坦丁堡，順利扶持支持威尼斯的政權;後期，威尼斯對於鄂圖曼土耳其的壓迫，動不動就想要暗殺其領袖，真不知道作者前面描寫那麼多威尼斯因為貿易需要所以兼容並蓄是為了什麼，最後還不是要動刀動槍)，不過也在其中得到了一些從國中以來的困惑。當初國中世界史章節的封面有一張十字軍攻陷君士坦丁堡的畫，可是在於國中歷史課本之中根本沒有去解釋有著大義的十字軍為什麼需要去攻陷有著東羅馬帝國的首都。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;小說&#34;&gt;小說&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文學少女

&lt;ul&gt;
&lt;li&gt;拿許多知名的經典小說的情節去進行重新的演繹，不過在沒有看過採用的經典的讀者而言，或多或少會失去部份的樂趣。表面上是對於經典情節的重新詮釋，深處其實在於主角的心理陰影(「心葉，你一定不懂吧。」)與女主角布局到最後一集的深意，本傳前後有8本，不算少，看的到是挺輕鬆的，沒有壓力與需要重覆理解的章節。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大典

&lt;ul&gt;
&lt;li&gt;一本用近現代科技去寫的科幻小說，前面看起來鋪陳不錯，可是一到中間的轉折看起來就很勉強。先不論其過於牽強的情節，這本書想要告訴讀者的主題是，集權國家藉由科技的力量控制國家的極致後，會發生什麼事情。根據作者推想之後得出的結論是，操作科技的技術人員會成為最大的漏洞，而集權也會因為這份過強的科技輕易的覆滅。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;吃掉死神的少女

&lt;ul&gt;
&lt;li&gt;整體看來，著實過於著重在對於戰爭殘酷的描寫，用於去陪襯主角的瘋狂與已經不屬於人的心態。整體的步調顯得沉悶，我給予的評價並沒有如同網路上的評價一樣高。過度描寫的血腥場景只會造成閱讀的障礙。相較之下，對於其他配角的描寫就出色了許多，一如主角的副官在尋找一個可以用來信仰的英雄;軍官為了家族的榮光不惜動用各種狡計;走頭無路的國王對於臣子的寬容。比起主角都更加的像個人。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;盜夢偵探&lt;/li&gt;
&lt;li&gt;新本格魔法少女莉絲佳

&lt;ul&gt;
&lt;li&gt;因為作者是西尾維新，所以一開始就有預感這不會是什麼正常的魔法少女，主角群肯定都是一些人格異常的傢伙。實際看下來也實際如此。雖然主角群人格異常，可是並沒有脫離古典魔法少女的公式(事件-&amp;gt;嘗試解決-&amp;gt;失敗-&amp;gt;交給魔法少女變身作結)，可是至今這個系列只有兩本，感受不到西尾維新的誠意阿。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;黑暗的左手

&lt;ul&gt;
&lt;li&gt;科幻。虛構的星球。虛構的新人類。移除了人與人之間於性別的隔閡。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;阿特拉斯聳聳肩

&lt;ul&gt;
&lt;li&gt;這本書是遊戲 bioshock 的靈感來源，可以說是這本小說的續集，在演示如果這個所謂有能力的人所建構出來的烏托邦成真其後續的結果。原書鼓吹自由主義，右派的極致。相信個人的努力遠超過環境的影響。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;駭客與畫家

&lt;ul&gt;
&lt;li&gt;我認為過譽了。全書有將近一半的篇幅都在吹捧作者在成立公司期間的豐功偉業。另外一半在談作者所認知的世界應該是怎麼樣運作的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他非虛構&#34;&gt;其他非虛構&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;老科技的全球史&lt;/li&gt;
&lt;li&gt;娛樂至死 : 追求表象﹑歡笑和激情的電視時代&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>英文學習</title>
      <link>https://bemg.github.io/blog/posts/learn-english/</link>
      <pubDate>Tue, 20 Feb 2018 13:46:33 +0800</pubDate>
      
      <guid>https://bemg.github.io/blog/posts/learn-english/</guid>
      <description>

&lt;p&gt;紀錄一下到目前為止對於英文學習的心得與方法。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;英文對我來說很困難，從小學就有的科目而言，長達十幾年的學習。依舊仍然停滯在沒有辦法自在運用的程度。&lt;/p&gt;

&lt;p&gt;直到近期才真正的正視英文能力的養成。故在此紀錄我從2017/07開始至今的英文學習歷程。希望可以給有相同困擾的人一個努力的方向。&lt;/p&gt;

&lt;h2 id=&#34;本文&#34;&gt;本文&lt;/h2&gt;

&lt;h3 id=&#34;目標&#34;&gt;目標&lt;/h3&gt;

&lt;p&gt;我對於學習英文的第一階段目標是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;閱讀原文文章&lt;/li&gt;
&lt;li&gt;看英文影片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是聽與讀的部份。&lt;/p&gt;

&lt;p&gt;在技術的方面，由英文所撰寫的第一手文章，其數量與正確度比起經過翻譯的第二手文章來說，都高上許多。&lt;/p&gt;

&lt;p&gt;故先以這兩項能力為目前的目標。&lt;/p&gt;

&lt;h3 id=&#34;閱讀&#34;&gt;閱讀&lt;/h3&gt;

&lt;p&gt;閱讀所使用的材料多半取自於新聞與技術文章。而在閱讀的過程中，我意識到了英文能力低落的關鍵，單字量完全不足，在一句英文句子有高達三個單字完全無法理解的情況下，要理解其想要傳達的含意簡直是癡人說夢。&lt;/p&gt;

&lt;h3 id=&#34;聽力&#34;&gt;聽力&lt;/h3&gt;

&lt;p&gt;我用來練習的影片多半來自於youtube&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCCODtTcd5M1JavPCOr_Uydg&#34;&gt;Extra Credits&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;這個頻道有很多的關於歷史與遊戲機制設計的影片。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很遺憾的是，很多時候沒有辦法聽懂內容跟單字量有相當高的相關，根本就不理解那個單字，是要怎麼可以從一連串的發音中辨識出來想要提供的含意。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;根據我一個英文很好的同學表示，裡面的單字水準真的是比較高。或許該找一下有沒有比較符合我這個英文水準的好頻道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;現階段的努力&#34;&gt;現階段的努力&lt;/h2&gt;

&lt;p&gt;總結上述的問題，充實我的英文單字量是刻不容緩的工作。&lt;/p&gt;

&lt;p&gt;起先我拿出了我塵封已久的高中7000單字書，步上了過去高中的單字學習法。重溫了高中的單字學習的過程中，我進行了幾項對於方法的修正。我不再要求可以對於英文單字每一個字母都可以熟記，雖然因為在於高中時期需要熟記拼字才可以有辦法成功的寫英文考卷。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;很快的，7000單字都已經被我輸入到anki之中了，現在就是見識它的威力的時刻。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我使用了一些輔助的被單字軟體&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;anki

&lt;ul&gt;
&lt;li&gt;免費的，可以用xml或者css客製化字卡的外觀。並且遵循著學習遺忘曲線進行單字的複習。&lt;/li&gt;
&lt;li&gt;我現在的設置為50個新單字 250 複習的單字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;更新&#34;&gt;更新&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2018/03/27

&lt;ul&gt;
&lt;li&gt;得到了一些新的想法，對於單字卡來說。正面：一個生字搭配一個例句，背面：單字的中文解釋。這樣的搭配可以有效的記憶中文解釋，而且這個搭配也是正常閱讀的時候所擁有的上下文。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>